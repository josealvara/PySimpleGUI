<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="None">
        
        
        <link rel="shortcut icon" href="img/favicon.ico">
        <title>My Docs</title>
        <link href="css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="css/font-awesome.min.css" rel="stylesheet">
        <link href="css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="js/jquery-1.10.2.min.js" defer></script>
        <script src="js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body class="homepage">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href=".">My Docs</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="active">
                                <a href=".">Home</a>
                            </li>
                            <li >
                                <a href="architecture/">Architecture</a>
                            </li>
                            <li >
                                <a href="cookbook/">Cookbook</a>
                            </li>
                            <li >
                                <a href="tutorial/">Tutorial</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="disabled">
                                <a rel="next" >
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="architecture/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#pysimplegui">PySimpleGUI</a></li>
            <li><a href="#supports-both-python-27-3-when-using-tkinter">Supports both Python 2.7 &amp; 3 when using tkinter</a></li>
            <li><a href="#supports-both-pyside2-and-pyqt5-limited-support">Supports both PySide2 and PyQt5 (limited support)</a></li>
            <li><a href="#effortlessly-move-across-tkinter-qt-wxpython-and-the-web-remi-by-changing-only-the-import-statement">Effortlessly move across tkinter, Qt, WxPython, and the Web (Remi) by changing only the import statement</a></li>
            <li><a href="#the-only-way-to-write-both-desktop-and-web-based-guis-at-the-same-time">The only way to write both desktop and web based GUIs at the same time</a></li>
        <li class="main "><a href="#qt-version">Qt Version</a></li>
            <li><a href="#source-code-compatibility">Source code compatibility</a></li>
        <li class="main "><a href="#wxpython-version">WxPython Version</a></li>
        <li class="main "><a href="#web-version-remi">Web Version (Remi)</a></li>
        <li class="main "><a href="#replit-version">repl.it Version</a></li>
        <li class="main "><a href="#support">Support</a></li>
        <li class="main "><a href="#platforms">Platforms</a></li>
            <li><a href="#features">Features</a></li>
        <li class="main "><a href="#getting-started-with-pysimplegui">Getting Started with PySimpleGUI</a></li>
            <li><a href="#installing-pysimplegui">Installing PySimpleGUI</a></li>
            <li><a href="#using-python-3">Using  - Python 3</a></li>
            <li><a href="#using-python-27">Using  - Python 2.7</a></li>
            <li><a href="#code-samples-assume-python-3">Code Samples Assume Python 3</a></li>
        <li class="main "><a href="#apis">APIs</a></li>
            <li><a href="#python-language-features">Python Language Features</a></li>
        <li class="main "><a href="#high-level-api-calls-popups">High Level API Calls  - Popup's</a></li>
            <li><a href="#popup-output">Popup Output</a></li>
            <li><a href="#popup-input">Popup Input</a></li>
        <li class="main "><a href="#progress-meters">Progress Meters!</a></li>
        <li class="main "><a href="#debug-output">Debug Output</a></li>
        <li class="main "><a href="#custom-window-api-calls-your-first-window">Custom window API Calls  (Your First window)</a></li>
            <li><a href="#the-window-designer">The window Designer</a></li>
        <li class="main "><a href="#copy-these-design-patterns">Copy these design patterns!</a></li>
            <li><a href="#pattern-1-one-shot-window-read-into-list-or-dictionary-the-most-common-pattern">Pattern 1 - "One-shot Window" - Read into list or dictionary (The Most Common Pattern)</a></li>
            <li><a href="#pattern-2-a-persistent-window-multiple-reads-using-an-event-loop">Pattern 2 A - Persistent window (multiple reads using an event loop)</a></li>
            <li><a href="#pattern-2-b-persistent-window-multiple-reads-using-an-event-loop-updates-data-in-window">Pattern 2 B - Persistent window (multiple reads using an event loop + updates data in window)</a></li>
            <li><a href="#how-gui-programming-in-python-should-look-at-least-for-beginners">How GUI Programming in Python Should Look?  At least for beginners ?</a></li>
            <li><a href="#return-values">Return values</a></li>
            <li><a href="#events">Events</a></li>
            <li><a href="#the-event-loop-callback-functions">The Event Loop / Callback Functions</a></li>
            <li><a href="#all-widgets-elements">All Widgets / Elements</a></li>
        <li class="main "><a href="#building-custom-windows">Building Custom Windows</a></li>
            <li><a href="#synchronous-windows">Synchronous windows</a></li>
        <li class="main "><a href="#window-object-beginning-a-window">Window Object - Beginning a window</a></li>
            <li><a href="#window-location">Window Location</a></li>
            <li><a href="#window-size">Window Size</a></li>
            <li><a href="#element-sizes">Element Sizes</a></li>
            <li><a href="#no-titlebar">No Titlebar</a></li>
            <li><a href="#grab-anywhere">Grab Anywhere</a></li>
            <li><a href="#always-on-top">Always on top</a></li>
            <li><a href="#focus">Focus</a></li>
            <li><a href="#window-methods-things-you-can-do-with-a-window-object">Window Methods (things you can do with a Window object)</a></li>
            <li><a href="#window-methods">Window Methods</a></li>
        <li class="main "><a href="#elements">Elements</a></li>
            <li><a href="#common-element-parameters">Common Element Parameters</a></li>
            <li><a href="#shortcut-functions-multiple-function-names">Shortcut Functions / Multiple Function Names</a></li>
            <li><a href="#text-element">Text Element</a></li>
            <li><a href="#multiline-text-element">Multiline Text Element</a></li>
            <li><a href="#output-element">Output Element</a></li>
            <li><a href="#input-elements">Input Elements</a></li>
            <li><a href="#text-input-element-shortcuts-input-in">Text Input Element    Shortcuts (Input, In)</a></li>
            <li><a href="#combo-element">Combo Element</a></li>
            <li><a href="#listbox-element">Listbox Element</a></li>
            <li><a href="#slider-element">Slider Element</a></li>
            <li><a href="#radio-button-element">Radio Button Element</a></li>
            <li><a href="#checkbox-element">Checkbox Element</a></li>
            <li><a href="#spin-element">Spin Element</a></li>
            <li><a href="#image-element">Image Element</a></li>
            <li><a href="#button-element">Button Element</a></li>
            <li><a href="#buttonmenu-element">ButtonMenu Element</a></li>
            <li><a href="#vertical-separator-element">Vertical Separator Element</a></li>
            <li><a href="#progressbar-element">ProgressBar  Element</a></li>
            <li><a href="#column-element">Column Element</a></li>
            <li><a href="#frame-element-labelled-frames-frames-with-a-title">Frame Element (Labelled Frames, Frames with a title)</a></li>
            <li><a href="#canvas-element">Canvas Element</a></li>
            <li><a href="#graph-element">Graph Element</a></li>
            <li><a href="#table-element">Table Element</a></li>
            <li><a href="#tree-element">Tree Element</a></li>
            <li><a href="#tab-and-tab-group-elements">Tab and Tab Group Elements</a></li>
            <li><a href="#pane-element">Pane Element</a></li>
            <li><a href="#colors_1">Colors</a></li>
        <li class="main "><a href="#systemtray">SystemTray</a></li>
            <li><a href="#system-tray-design-pattern">System Tray Design Pattern</a></li>
            <li><a href="#menu-definition">Menu Definition</a></li>
            <li><a href="#systemtray-methods">SystemTray Methods</a></li>
        <li class="main "><a href="#global-settings">Global Settings</a></li>
        <li class="main "><a href="#persistent-windows-window-stays-open-after-button-click">Persistent windows (Window stays open after button click)</a></li>
            <li><a href="#readtimeout-t-timeout_keytimeout">Read(timeout = t, timeout_key='timeout')</a></li>
            <li><a href="#non-blocking-windows-asynchronous-reads">Non-Blocking Windows   (Asynchronous reads)</a></li>
            <li><a href="#sgtimeout_key">sg.TIMEOUT_KEY</a></li>
            <li><a href="#persistent-window-example-running-timer-that-updates">Persistent Window Example - Running timer that updates</a></li>
            <li><a href="#instead-of-a-non-blocking-read-use-change_submits-true-or-return_keyboard_events-true">Instead of a Non-blocking Read --- Use change_submits = True or return_keyboard_events = True</a></li>
        <li class="main "><a href="#updating-elements-changing-elements-in-active-window">Updating Elements (changing elements in active window)</a></li>
            <li><a href="#locating-elements">Locating Elements</a></li>
            <li><a href="#progressbar-progress-meters">ProgressBar / Progress Meters</a></li>
        <li class="main "><a href="#keyboard-mouse-capture">Keyboard &amp; Mouse Capture</a></li>
            <li><a href="#realtime-keyboard-capture">Realtime Keyboard Capture</a></li>
        <li class="main "><a href="#menus">Menus</a></li>
            <li><a href="#menubar">MenuBar</a></li>
            <li><a href="#buttonmenus">ButtonMenus</a></li>
            <li><a href="#right-click-menus">Right Click Menus</a></li>
            <li><a href="#menu-shortcut-keys">Menu Shortcut keys</a></li>
            <li><a href="#disabled-menu-entries">Disabled Menu Entries</a></li>
            <li><a href="#keys-for-menus">Keys for Menus</a></li>
        <li class="main "><a href="#running-multiple-windows">Running Multiple Windows</a></li>
            <li><a href="#multi-window-design-pattern-1-both-windows-active">Multi-Window Design Pattern 1 - both windows active</a></li>
            <li><a href="#multi-window-design-pattern-2-only-1-active-window">Multi-Window Design Pattern 2 - only 1 active window</a></li>
        <li class="main "><a href="#sample-applications">Sample Applications</a></li>
            <li><a href="#packages-used-in-demos">Packages Used In Demos</a></li>
        <li class="main "><a href="#creating-a-windows-exe-file">Creating a Windows .EXE File</a></li>
        <li class="main "><a href="#creating-a-mac-app-file">Creating a Mac App File</a></li>
            <li><a href="#fun-stuff">Fun Stuff</a></li>
        <li class="main "><a href="#known-issues">Known Issues</a></li>
            <li><a href="#do-not-attempt-to-call-pysimplegui-from-multiple-threads-its-tkinter-based-and-tkinter-has-issues-with-multiple-threads">Do not attempt to call PySimpleGUI from multiple threads! It's tkinter based and tkinter has issues with multiple threads</a></li>
            <li><a href="#contributing">Contributing</a></li>
            <li><a href="#versions">Versions</a></li>
            <li><a href="#release-notes">Release Notes</a></li>
            <li><a href="#3180-11-dec-2018">3.18.0  11-Dec-2018</a></li>
            <li><a href="#3192-13-dec-2018">3.19.2  13-Dec-2018</a></li>
            <li><a href="#3200-1200-18-dec-2018">3.20.0 &amp; 1.20.0 18-Dec-2018</a></li>
            <li><a href="#3210-1210-28-dec-2018">3.21.0 &amp; 1.21.0 28-Dec-2018</a></li>
        <li class="main "><a href="#3220-pysimplegui-1220-pysimplegui27">3.22.0 PySimpleGUI / 1.22.0 PySimpleGUI27</a></li>
        <li class="main "><a href="#3230-pysimplegui-1230-pysimplegui27-16-jan-2019">3.23.0 PySimpleGUI /  1.23.0 PySimpleGUI27 16-Jan-2019</a></li>
        <li class="main "><a href="#3240-1240-16-jan-2019">3.24.0 1.24.0 16-Jan-2019</a></li>
        <li class="main "><a href="#325-125-20-feb-2019">3.25 &amp; 1.25 20-Feb-2019</a></li>
            <li><a href="#upcoming">Upcoming</a></li>
            <li><a href="#code-condition">Code Condition</a></li>
            <li><a href="#design">Design</a></li>
            <li><a href="#author">Author</a></li>
            <li><a href="#demo-code-contributors">Demo Code Contributors</a></li>
            <li><a href="#license">License</a></li>
            <li><a href="#acknowledgments">Acknowledgments</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><img alt="pysimplegui_logo" src="https://user-images.githubusercontent.com/13696193/43165867-fe02e3b2-8f62-11e8-9fd0-cc7c86b11772.png" />      </p>
<p><a href="http://pepy.tech/project/pysimplegui"><img alt="Downloads" src="http://pepy.tech/badge/pysimplegui" /></a>        tkinter
<a href="https://pepy.tech/project/pysimplegui27"><img alt="Downloads " src="https://pepy.tech/badge/pysimplegui27" /></a>      tkinter 2.7
<a href="https://pepy.tech/project/pysimpleguiqt"><img alt="Downloads" src="https://pepy.tech/badge/pysimpleguiqt" /></a>   Qt
<a href="https://pepy.tech/project/pysimpleguiWx"><img alt="Downloads" src="https://pepy.tech/badge/pysimpleguiwx" /></a>    WxPython
<a href="https://pepy.tech/project/pysimpleguiWeb"><img alt="Downloads" src="https://pepy.tech/badge/pysimpleguiweb" /></a>   Web (Remi)
<img alt="Documentation Status" src="https://readthedocs.org/projects/pysimplegui/badge/?version=latest" />    <br />
<img alt="Awesome Meter" src="https://img.shields.io/badge/Awesome_meter-100-yellow.svg" />    <br />
<img alt="Python Version" src="https://img.shields.io/badge/Python-2.7_3.x-yellow.svg" />      </p>
<h1 id="pysimplegui">PySimpleGUI</h1>
<h2 id="supports-both-python-27-3-when-using-tkinter">Supports both Python 2.7 &amp; 3 when using tkinter</h2>
<h2 id="supports-both-pyside2-and-pyqt5-limited-support">Supports both PySide2 and PyQt5 (limited support)</h2>
<h2 id="effortlessly-move-across-tkinter-qt-wxpython-and-the-web-remi-by-changing-only-the-import-statement">Effortlessly move across tkinter, Qt, WxPython, and the Web (Remi) by changing only the import statement</h2>
<h2 id="the-only-way-to-write-both-desktop-and-web-based-guis-at-the-same-time">The <em>only</em> way to write both desktop and web based GUIs at the same time</h2>
<p><img alt="Python Version" src="https://img.shields.io/badge/PySimpleGUI_For_Python_3.x_Version-3.25.0-red.svg?longCache=true&amp;style=for-the-badge" />      </p>
<p><img alt="Python Version" src="https://img.shields.io/badge/PySimpleGUI_For_Python_2.7_Version-1.25.0-blue.svg?longCache=true&amp;style=for-the-badge" />      </p>
<p><img alt="Python Version" src="https://img.shields.io/badge/PySimpleGUIQt_Version-0.22.0-orange.svg?longCache=true&amp;style=for-the-badge" />    </p>
<p><img alt="Python Version" src="https://img.shields.io/badge/PySimpleGUIWx_version-0.3.0-orange.svg?longCache=true&amp;style=for-the-badge" /></p>
<p><img alt="Python Version" src="https://img.shields.io/badge/PySimpleGUIWeb_Version-0.10.0-orange.svg?longCache=true&amp;style=for-the-badge" /></p>
<p><a href="https://github.com/MikeTheWatchGuy/PySimpleGUI/issues/142">Announcements of Latest Developments</a>      </p>
<p><a href="http://pysimplegui.readthedocs.io/">ReadTheDocs</a>      </p>
<p><a href="https://pysimplegui.readthedocs.io/cookbook/">COOKBOOK!</a>      </p>
<p><a href="https://pysimplegui.readthedocs.io/tutorial/">Brief Tutorial</a>      </p>
<p><a href="https://github.com/MikeTheWatchGuy/PySimpleGUI">Latest Demos and Master Branch on GitHub</a>      </p>
<p><a href="https://github.com/MikeTheWatchGuy/PySimpleGUI/tree/master/docs">Docs in PDF Format</a>      </p>
<p><a href="https://repl.it/@PySimpleGUI">Repl.it Home for PySimpleGUI</a></p>
<p>Super-simple GUI to use... Powerfully customizable    </p>
<p>Home of the 1-line custom GUI &amp; 1-line progress meter      </p>
<p>The native GUI framework for perfectionists with deadlines    </p>
<p>Actively developed and supported (It's 2019 and still going strong)</p>
<h4 id="note-regarding-python-versions">Note regarding Python versions</h4>
<p>As of 9/25/2018 <strong>both Python 3 and Python 2.7 are supported</strong>!   The Python 3 version is named <code>PySimpleGUI</code>. The Python 2.7 version is <code>PySimpleGUI27</code>.  They are installed separately and the imports are different. See instructions in Installation section for more info.      </p>
<h1 id="qt-version">Qt Version</h1>
<p>Check out the new PySimpleGUI port to the Qt GUI Framework.  You can learn more on the <a href="https://github.com/MikeTheWatchGuy/PySimpleGUI/tree/master/PySimpleGUIQt">PySimpleGUIQt GitHub site</a>.  <strong>There is a separate Readme file for the Qt version</strong> that you'll find there.  </p>
<p>Give it a shot if you're looking for something a bit more "modern".  PySimpleGUIQt is currently in Alpha.  All of the widgets are operational but some may not yet be full-featured.  If one is missing and your project needs it, log an Issue and you'll likely get priority support. </p>
<p>Here is a summary of the Qt Elements</p>
<p><img alt="scrolling graphics" src="https://user-images.githubusercontent.com/13696193/48665874-8bfd0e00-ea84-11e8-880d-8e164d9fea34.gif" /></p>
<p>Are there enough things on there to cover your GUI solution?</p>
<h2 id="source-code-compatibility">Source code compatibility</h2>
<p>Your source code is completely portable from one platform to another by simply changing the import statement.</p>
<h1 id="wxpython-version">WxPython Version</h1>
<p><a href="https://github.com/PySimpleGUI/PySimpleGUI/tree/master/PySimpleGUIWx">PySimpleGUIWx GitHub site</a>.  <strong>There is a separate Readme file for the WxPython version</strong>.</p>
<p>Started in late December 2018 PySimpleGUIWx started with the SystemTray Icon feature.    This enabled the package to have one fully functioning feature that can be used along with tkinter to provide a complete program.    The System Tray feature is complete and working very well.</p>
<p>The Windowing code is coming together with Reads now operational which means Popups work.  The elements are getting completed on a regular basis.  3 more were just checked in. At least 1 new element is getting completed a week.  </p>
<h1 id="web-version-remi">Web Version (Remi)</h1>
<p><a href="https://github.com/PySimpleGUI/PySimpleGUI/tree/master/PySimpleGUIWeb">PySimpleGUIWeb GitHub site</a>.  <strong>There is a separate Readme file for the Web version</strong>.</p>
<p>New for 2019, PySimpleGUIWeb.  This is an exciting development!  PySimpleGUI in your Web Browser!</p>
<p>The underlying framework supplying the web capability is the Python package Remi.  https://github.com/dddomodossola/remi  Remi provides the widgets as well as a web server for you to connect to.  It's an exiting new platform to be running on and has temporarily bumped the WxPython port from the highest priority.  PySimpleGUIWeb is the current high priority project.</p>
<p>Read on and you'll understand even more why this is an important project...</p>
<h1 id="replit-version">repl.it Version</h1>
<p><strong><em>Want to really get your mind blown?</em></strong>  Check out this <a href="https://repl.it/@PySimpleGUI/PySimpleGUIWeb-Demos">PySimpleGUI program</a> running in your web browser.</p>
<p>Thanks to the magic of repl.it and Remi it's possible to run PySimpleGUI code in a browser window without having Python running on your computer.  </p>
<p>The programs you write using repl.it will automatically download and install the latest PySimpleGUIWeb from PyPI onto a virtual Python environment.  All that is required is to type <code>import PySimpleGUIWeb</code> you'll have a Python environment up and running with the latest PyPI release of PySimpleGUIWeb.  </p>
<p>This is an exciting new development that's opening up all kinds of possibilities for new ways to program and learn PySimpleGUI.   Stayed tuned, much more to be posted about this in the near future.  </p>
<p>Educators in particular should be interested.  Students can not only post their homework easily for their teacher to access, but teachers can also run the students programs online.  No downloading needed.  Run it and check the results.</p>
<p>Depending on how you're viewing this document, you may or may not see an embedded browser window below that is running PySimpleGUI code.</p>
<iframe height="1000px" width="100%" src="https://repl.it/@PySimpleGUI/PySimpleGUIWeb-Demos?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

<h1 id="support">Support</h1>
<p>PySimpleGUI is an active project.  Bugs are fixed, features are added, often.  Should you run into trouble, open an issue on the GitHub site and you'll receive help by someone in the community.  </p>
<h1 id="platforms">Platforms</h1>
<p>It's surprising that Python GUI code is completely cross platform from Windows to Mac to Linux.  No source code changes.  This is true for both  PySimpleGUI and PySimpleGUIQt.</p>
<p>However, <strong>Macs</strong> suck.  They suck on tkinter in particular.  The "Look and feel" calls are disabled for Macs.  Colored buttons in particular are broken.  Not in the PySimpleGUI code, of course.    It's mostly because Macs suck.  Consider using Qt instead of tkinter on the Mac.  Or, if using tkinter, bring your own button images. </p>
<hr />
<p>Looking for a GUI package?     Are you </p>
<ul>
<li>looking to take your Python code from the world of command lines and into the convenience of a GUI?  *      </li>
<li>sitting on a Raspberry <strong>Pi</strong> with a touchscreen that's going to waste because you don't have the time to learn a GUI SDK?      </li>
<li>into Machine Learning and are sick of the command line?      </li>
<li>wanting to distribute your Python code to Windows users as a single .EXE file that launches straight into a GUI, much like a WinForms app?      </li>
<li>would like to run a program in the system tray?</li>
<li>a teacher wanting to teach your students how to program using a GUI?</li>
<li>a student that wants to put a GUI onto their project?</li>
<li>looking for an active project?</li>
</ul>
<p>Look no further, <strong>you've found your GUI package</strong>.      </p>
<pre><code>import PySimpleGUI as sg

sg.Popup('Hello From PySimpleGUI!', 'This is the shortest GUI program ever!')
</code></pre>
<p><img alt="hello world" src="https://user-images.githubusercontent.com/13696193/44960047-1f7f6380-aec6-11e8-9d5e-12ef935bcade.jpg" />      </p>
<p>Or how about a <strong><em>custom GUI</em></strong> in 1 line of code?      </p>
<pre><code>import PySimpleGUI as sg

event, (filename,) = sg.Window('Get filename example'). Layout([[sg.Text('Filename')], [sg.Input(), sg.FileBrowse()], [sg.OK(), sg.Cancel()] ]).Read()
</code></pre>
<p><img alt="get filename" src="https://user-images.githubusercontent.com/13696193/44960039-f1018880-aec5-11e8-8a43-3d7f8ff93b67.jpg" />      </p>
<p>Build beautiful customized windows that fit your specific problem.  Let PySimpleGUI solve your GUI problem while you solve your real problems.   Look through the Cookbook, find a matching recipe, copy, paste, run within minutes.  This is the process PySimpleGUI was designed to facilitate.      </p>
<p>Your windows don't have to look like "boring" old windows.  Add a few custom graphics to your windows to polish things up.</p>
<p><img alt="batterup2" src="https://user-images.githubusercontent.com/13696193/50378902-6aa2bb00-060a-11e9-8f2f-d746694fa4ee.gif" /></p>
<p><img alt="uno_final" src="https://user-images.githubusercontent.com/13696193/49945232-67952580-feba-11e8-90c8-7dc31c5f7c67.gif" />     </p>
<p>PySimpleGUI wraps tkinter or Qt so that you get all the same widgets as you would tkinter/Qt, but you interact with them in a more friendly way.  It does the layout and boilerplate code for you and presents you with a simple, efficient interface.      </p>
<p><img alt="everything dark theme" src="https://user-images.githubusercontent.com/13696193/44959854-b1d23800-aec3-11e8-90b6-5af915a86d15.jpg" />      </p>
<p>Perhaps you're looking for a way to interact with your <strong>Raspberry Pi</strong> in a more friendly way.  The same for shown as on Pi (roughly the same)      </p>
<p><img alt="raspberry pi everything demo" src="https://user-images.githubusercontent.com/13696193/44279694-5b58ce80-a220-11e8-9ab6-d6021f5a944f.jpg" />      </p>
<p>In addition to a primary GUI, you can add a Progress Meter to your code with ONE LINE of code.  Slide this line into any of your <code>for</code> loops and get a nice meter:      </p>
<pre><code>OneLineProgressMeter('My meter title', current_value, max value, 'key')
</code></pre>
<p><img alt="easyprogressmeter" src="https://user-images.githubusercontent.com/13696193/44960065-83099100-aec6-11e8-8aa8-96e4b100a0e4.jpg" />      </p>
<p>It's simple to show animated GIFs. </p>
<p><img alt="loading animation" src="https://user-images.githubusercontent.com/13696193/51280871-d2041e80-19ae-11e9-8757-802eb95352ed.gif" />      </p>
<p>How about embedding a game inside of a GUI?  This game of Pong is written in tkinter and then dropped into the PySimpleGUI window creating a game that has an accompanying GUI.      </p>
<p><img alt="pong" src="https://user-images.githubusercontent.com/13696193/45860012-2d8d0b00-bd33-11e8-9efd-3eaf4c30f324.gif" />      </p>
<p>Combining PySimpleGUI with PyInstaller creates something truly remarkable and special, a Python program that looks like a Windows WinForms application.  This application with working menu was created in 20 lines of Python code.  It is a single .EXE file that launches straight into the screen you see.  And more good news, the only icon you see on the taskbar is the window itself... there is no pesky shell window.      </p>
<p><img alt="menu demo" src="https://user-images.githubusercontent.com/13696193/45923097-8fbc4c00-beaa-11e8-87d2-01a5331811c8.gif" />      </p>
<p>## Background    <br />
I was frustrated by having to deal with the dos prompt when I had a powerful Windows machine right in front of me.  Why is it SO difficult to do even the simplest of input/output to a window in Python??      </p>
<p>There are a number of 'easy to use' Python GUIs, but they were too limited for my requirements.  PySimpleGUI aims for the same simplicity found in packages like <code>EasyGUI</code>and <code>WxSimpleGUI</code> , both really handy but limited, and adds the ability to define your own layouts.   This ability to make your own windows using a large palette of widgets is but one difference  between the existing "simple" packages and <code>PySimpleGUI</code>.      </p>
<p>With a simple GUI, it becomes practical to "associate" .py files with the python interpreter on Windows.  Double click a py file and up pops a GUI window, a more pleasant experience than opening a dos Window and typing a command line.      </p>
<p>The <code>PySimpleGUI</code> package is focused on the <strong><em>developer</em></strong>.      </p>
<blockquote>
<p>Create a custom GUI with as little and as simple code as possible.      </p>
</blockquote>
<p>This was the primary focus used to create PySimpleGUI.      </p>
<blockquote>
<p>"Do it in a Python-like way"      </p>
</blockquote>
<p>was the second.      </p>
<h2 id="features">Features</h2>
<p>While simple to use, PySimpleGUI has significant depth to be explored by more advanced programmers.  The feature set goes way beyond the requirements of a beginner programmer, and into the  required features needed for complex GUIs.      </p>
<pre><code>Features of PySimpleGUI include:      
    Support for Python versions 2.7 and 3      
    Text      
    Single Line Input      
    Buttons including these types:      
        File Browse      
        Files Browse      
        Folder Browse      
        SaveAs      
        Non-closing return      
        Close window      
        Realtime      
        Calendar chooser      
        Color chooser   
        Button Menu   
    Checkboxes      
    Radio Buttons      
    Listbox      
    Option Menu 
    Menubar
    Button Menu     
    Slider      
    Dial
    Graph      
    Frame with title      
    Icons      
    Multi-line Text Input      
    Scroll-able Output      
    Images      
    Tables    
    Trees    
    Progress Bar            Async/Non-Blocking Windows      
    Tabbed windows      
    Paned windows
    Persistent Windows      
    Redirect Python Output/Errors to scrolling window      
    'Higher level' APIs (e.g. MessageBox, YesNobox, ...)      
    Single-Line-Of-Code Proress Bar &amp; Debug Print      
    Complete control of colors, look and feel      
    Selection of pre-defined palettes      
    Button images      
    Horizontal and Verticle Separators
    Return values as dictionary      
    Set focus      
    Bind return key to buttons      
    Group widgets into a column and place into window anywhere      
    Scrollable columns      
    Keyboard low-level key capture      
    Mouse scroll-wheel support      
    Get Listbox values as they are selected      
    Get slider, spinner, combo as they are changed      
    Update elements in a live window      
    Bulk window-fill operation      
    Save / Load window to/from disk      
    Borderless (no titlebar) windows      
    Always on top windows      
    Menus with ALT-hotkey    
    Right click pop-up menu  
    Tooltips      
    Clickable links    
    Transparent windows
    Movable windows  
    Animated GIFs
    No async programming required (no callbacks to worry about)
</code></pre>
<p>An example of many widgets used on a single window.  A little further down you'll find the 21 lines of code required to create this complex window.  Try it if you don't believe it.  Install PySimpleGUI then :      </p>
<blockquote>
<p>Start Python, copy and paste the code below into the &gt;&gt;&gt; prompt and hit enter. This will pop up...    <br />
</p>
</blockquote>
<p><img alt="everything example" src="https://user-images.githubusercontent.com/13696193/43097412-0a4652aa-8e8a-11e8-8e09-939484e3c568.jpg" />      </p>
<pre><code>import PySimpleGUI as sg

layout = [[sg.Text('All graphic widgets in one window!', size=(30, 1), font=("Helvetica", 25), text_color='blue')],      
   [sg.Text('Here is some text.... and a place to enter text')],      
   [sg.InputText()],      
   [sg.Checkbox('My first checkbox!'), sg.Checkbox('My second checkbox!', default=True)],      
   [sg.Radio('My first Radio!     ', "RADIO1", default=True), sg.Radio('My second Radio!', "RADIO1")],      
   [sg.Multiline(default_text='This is the default Text shoulsd you decide not to type anything',)],      
[sg.InputCombo(['Combobox 1', 'Combobox 2'], size=(20, 3)),      
 sg.Slider(range=(1, 100), orientation='h', size=(35, 20), default_value=85)],      
[sg.Listbox(values=['Listbox 1', 'Listbox 2', 'Listbox 3'], size=(30, 6)),      
 sg.Slider(range=(1, 100), orientation='v', size=(10, 20), default_value=25),      
 sg.Slider(range=(1, 100), orientation='v', size=(10, 20), default_value=75),      
 sg.Slider(range=(1, 100), orientation='v', size=(10, 20), default_value=10)],      
[sg.Text('_'  * 100, size=(70, 1))],      
[sg.Text('Choose Source and Destination Folders', size=(35, 1))],      
[sg.Text('Source Folder', size=(15, 1), auto_size_text=False, justification='right'), sg.InputText('Source'),      
 sg.FolderBrowse()],      
[sg.Text('Destination Folder', size=(15, 1), auto_size_text=False, justification='right'), sg.InputText('Dest'),      
 sg.FolderBrowse()],      
[sg.Submit(), sg.Cancel(), sg.Button('Customized', button_color=('white', 'green'))]]

event, values  = sg.Window('Everything bagel', auto_size_text=True, default_element_size=(40, 1)).Layout(layout).Read()
</code></pre>
<hr />
<h3 id="design-goals">Design Goals</h3>
<blockquote>
<p>Copy, Paste, Run.      </p>
</blockquote>
<p><code>PySimpleGUI's</code> goal with the API is to be easy on the programmer, and to function in a Python-like way. Since GUIs are visual, it was desirable for the code to visually match what's on the screen.  By providing a significant amount of documentation and an easy to use Cookbook, it's possible to see your first GUI within 5 minutes of beginning the installation.      </p>
<blockquote>
<p>Be Pythonic      </p>
</blockquote>
<p>Be Pythonic... Attempted to use language constructs in a natural way and to exploit some of Python's interesting features.  Python's lists and optional parameters make PySimpleGUI work smoothly.      </p>
<ul>
<li>windows are represented as Python lists.      <ul>
<li>A window is a list of rows      </li>
</ul>
</li>
<li>A row is a list of elements      </li>
<li>Return values are a list of button presses and input values.      </li>
<li>Return values can also be represented as a dictionary      </li>
<li>The SDK calls collapse down into a single line of Python code that presents a custom GUI and returns values      </li>
<li>Linear programming instead of callbacks      </li>
</ul>
<p>#### Lofty Goals      </p>
<blockquote>
<p>Change Python      </p>
</blockquote>
<p>The hope is not that <strong><em>this</em></strong> package will become part of the Python Standard Library.      </p>
<p>The hope is that Python will become <strong><em>the</em></strong> go-to language for creating GUI programs that run on Windows, Mac, and Linux <em>for all levels of developer</em>.      </p>
<p>The hope is that beginners that are interested in graphic design will have an easy way to express themselves, right from the start of their Python experience.      </p>
<p>There is a noticeable gap in the Python GUI solution.  Fill that gap and who knows what will happen.      </p>
<p>Maybe there's no "there there".  <strong><em>Or</em></strong> maybe a simple GUI API will enable Python to dominate yet another computing discipline like it has so many others.   This is my attempt to find out.      </p>
<hr />
<h1 id="getting-started-with-pysimplegui">Getting Started with PySimpleGUI</h1>
<h2 id="installing-pysimplegui">Installing PySimpleGUI</h2>
<h3 id="installing-python-3">Installing  Python 3</h3>
<pre><code>pip install --upgrade PySimpleGUI
</code></pre>
<p>On some systems you need to run pip3.      </p>
<pre><code>pip3 install --upgrade PySimpleGUI
</code></pre>
<p>On a Raspberry Pi, this is should work:      </p>
<pre><code>sudo pip3 install --upgrade pysimplegui
</code></pre>
<p>Some users have found that upgrading required using an extra flag on the pip <code>--no-cache-dir</code>.      </p>
<pre><code>pip install --upgrade --no-cache-dir
</code></pre>
<p>On some versions of Linux you will need to first install pip.  Need the Chicken before you can get the Egg (get it... Egg?)      </p>
<p><code>sudo apt install python3-pip</code>      </p>
<p>If for some reason you are unable to install using <code>pip</code>, don't worry, you can still import PySimpleGUI by downloading the file PySimleGUI.py and placing it in your folder along with the application that is importing it.      </p>
<p><code>tkinter</code> is a requirement for PySimpleGUI (the only requirement).  Some OS variants, such as Ubuntu, do not some with <code>tkinter</code> already installed.  If you get an error similar to:      </p>
<pre><code>ImportError: No module named tkinter      
</code></pre>

<p>then you need to install <code>tkinter</code>. 
For python 2.7</p>
<p><code>sudo apt-get install python-tk</code>   </p>
<p>For python 3
<code>sudo apt-get install python3-tk</code>      </p>
<p>More information about installing tkinter can be found here: https://www.techinfected.net/2015/09/how-to-install-and-use-tkinter-in-ubuntu-debian-linux-mint.html</p>
<h3 id="installing-for-python-27">Installing for Python 2.7</h3>
<p><code>pip install --upgrade PySimpleGUI27</code>  <br />
  or  <br />
<code>pip2 install --upgrade PySimpleGUI27</code>    </p>
<p>You may need to also install "future" for version 2.7    </p>
<pre><code>pip install future
</code></pre>
<p>or   <br />
<code>pip2 install future</code>    </p>
<p>Python 2.7 support is relatively new and the bugs are still being worked out.  I'm unsure what may need to be done to install tkinter for Python 2.7.  Will update this readme when more info is available      </p>
<p>Like above, you may have to install either pip or tkinter.  To do this on Python 2.7:      </p>
<p><code>sudo apt install python-pip</code>      </p>
<p><code>sudo apt install python-tkinter</code>      </p>
<h3 id="testing-your-installation">Testing your installation</h3>
<p>Once you have installed, or copied the .py file to your app folder, you can test the installation using python.  At the command prompt start up Python.      </p>
<h4 id="instructions-for-python-27">Instructions for Python 2.7:</h4>
<pre><code>python      
&gt;&gt;&gt; import PySimpleGUI27      
&gt;&gt;&gt; PySimpleGUI27.main()      
</code></pre>

<h4 id="instructions-for-python-3">Instructions for Python 3:</h4>
<pre><code>python3      
&gt;&gt;&gt; import PySimpleGUI      
&gt;&gt;&gt; PySimpleGUI.main()      
</code></pre>

<p>You will see a sample window in the center of your screen.  If it's not installed correctly you are likely to get an error message during one of those commands      </p>
<p>Here is the window you should see:      </p>
<p><img alt="sample window" src="https://user-images.githubusercontent.com/13696193/46097669-79efa500-c190-11e8-885c-e5d4d5d09ea6.jpg" />      </p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Python 2.7 or Python 3    <br />
tkinter      </p>
<p>PySimpleGUI Runs on all Python3 platforms that have tkinter running on them.  It has been tested on Windows, Mac, Linux, Raspberry Pi.  Even runs on <code>pypy3</code>.      </p>
<h3 id="exe-file-creation">EXE file creation</h3>
<p>If you wish to create an EXE from your PySimpleGUI application, you will need to install <code>PyInstaller</code>.  There are instructions on how to create an EXE at the bottom of this ReadMe      </p>
<h2 id="using-python-3">Using  - Python 3</h2>
<p>To use in your code, simply import....    <br />
<code>import PySimpleGUI as sg</code>      </p>
<p>Then use either "high level" API calls or build your own windows.      </p>
<pre><code>sg.Popup('This is my first Popup')
</code></pre>
<p><img alt="first popup" src="https://user-images.githubusercontent.com/13696193/44957300-c7813680-ae9e-11e8-9a8c-c70198db7907.jpg" />      </p>
<p>Yes, it's just that easy to have a window appear on the screen using Python.  With PySimpleGUI, making a custom window appear isn't much more difficult.  The goal is to get you running on your GUI within <strong><em>minutes</em></strong>, not hours nor days.      </p>
<h2 id="using-python-27">Using  - Python 2.7</h2>
<p>Those using Python 2.7 will import a different module name    <br />
<code>import PySimpleGUI27 as sg</code>      </p>
<h2 id="code-samples-assume-python-3">Code Samples Assume Python 3</h2>
<p>While all of the code examples you will see in this Readme and the  Cookbook assume Python 3 and thus have an <code>import PySimpleGUI</code> at the top, you can run <strong><em>all</em></strong> of this code on Python 2.7 by changing the import statement to <code>import PySimpleGUI27</code>      </p>
<hr />
<h1 id="apis">APIs</h1>
<p>PySimpleGUI can be broken down into 2 types of API's:    <br />
 * High Level single call functions    (The <code>Popup</code> calls)    <br />
 * Custom window functions      </p>
<h3 id="python-language-features">Python Language Features</h3>
<p>There are a number of Python language features that PySimpleGUI utilizes heavily for API access that should be understood...    <br />
 * Variable number of arguments to a function call    <br />
 * Optional parameters to a function call    <br />
 * Dictionaries      </p>
<h4 id="variable-number-of-arguments">Variable Number of Arguments</h4>
<p>The "High Level" API calls that <em>output</em> values take a variable number of arguments so that they match a "print" statement as much as possible.  The idea is to make it simple for the programmer to output as many items as desired and in any format.  The user need not convert the variables to be output into the strings.  The PySimpleGUI functions do that for the user.      </p>
<pre><code>sg.Popup('Variable number of parameters example', var1, var2, "etc")
</code></pre>
<p>Each new item begins on a new line in the Popup      </p>
<p><img alt="snap0179" src="https://user-images.githubusercontent.com/13696193/43658129-f6ca49c6-9725-11e8-9317-1f77443eb04a.jpg" />      </p>
<h4 id="optional-parameters-to-a-function-call">Optional Parameters to a Function Call</h4>
<p>This feature of the Python language is utilized <strong><em>heavily</em></strong> as a method of customizing windows and window Elements.  Rather than requiring the programmer to specify every possible option for a widget, instead only the options the caller wants to override are specified.      </p>
<p>Here is the function definition for the Popup function. The details aren't important.  What is important is seeing that there is a long list of potential tweaks that a caller can make.  However, they don't <em>have</em> to be specified on each and every call.      </p>
<pre><code>def Popup(*args,      
           button_color=None,      
           button_type=MSG_BOX_OK,      
           auto_close=False,      
           auto_close_duration=None,      
           icon=DEFAULT_WINDOW_ICON,      
           line_width=MESSAGE_BOX_LINE_WIDTH,      
           font=None):
</code></pre>
<p>If the caller wanted to change the button color to be black on yellow, the call would look something like this:      </p>
<pre><code>sg.Popup('This box has a custom button color', button_color=('black', 'yellow'))
</code></pre>
<p><img alt="snap0180" src="https://user-images.githubusercontent.com/13696193/43658171-13a72bfe-9726-11e8-8c7a-0a46e46fb202.jpg" />      </p>
<h4 id="dictionaries">Dictionaries</h4>
<p>Dictionaries are used by more advanced PySimpleGUI users.  You'll know that dictionaries are being used if you see a <code>key</code> parameter on any Element.  Dictionaries are used in 2 ways:    <br />
1. To identify values when a window is read    <br />
2. To identify Elements so that they can be "updated"      </p>
<hr />
<h1 id="high-level-api-calls-popups">High Level API Calls  - Popup's</h1>
<p>"High level calls" are those that start with "Popup".    They are the most basic form of communications with the user.   They are named after the type of window they create, a pop-up window.  These windows are meant to be short lived while, either delivering information or collecting it, and then quickly disappearing.      </p>
<h2 id="popup-output">Popup Output</h2>
<p>Think of the <code>Popup</code> call as the GUI equivalent of a  <code>print</code> statement.  It's your way of displaying results to a user in the windowed world.  Each call to Popup will create a new Popup window.      </p>
<p><code>Popup</code> calls are normally blocking.  your program will stop executing until the user has closed the Popup window.  A non-blocking window of Popup discussed in the async section.      </p>
<p>Just like a print statement, you can pass any number of arguments you wish.  They will all be turned into strings and displayed in the popup window.      </p>
<p>There are a number of Popup output calls, each with a slightly different look (e.g. different button labels).      </p>
<p>The list of Popup output functions are      </p>
<pre><code>Popup      
PopupOk      
PopupYesNo      
PopupCancel      
PopupOkCancel      
PopupError      
PopupTimed, PopupAutoClose      
PopupNoWait, PopupNonBlocking
</code></pre>
<p>The trailing portion of the function name after Popup indicates what buttons are shown.  <code>PopupYesNo</code> shows a pair of button with Yes and No on them.   <code>PopupCancel</code> has a Cancel button, etc.      </p>
<p>While these are "output" windows, they do collect input in the form of buttons.  The Popup functions return the button that was clicked.  If the Ok button was clicked, then Popup returns the string 'Ok'.  If the user clicked the X button to close the window, then the button value returned is <code>None</code>.      </p>
<p>The function <code>PopupTimed</code> or <code>PopupAutoClose</code> are popup windows that will automatically close after come period of time.      </p>
<p>Here is a quick-reference showing how the Popup calls look.      </p>
<pre><code>sg.Popup('Popup')  - Shows OK button    
sg.PopupOk('PopupOk')  - Shows OK button    
sg.PopupYesNo('PopupYesNo')  - Shows Yes and No buttons    
sg.PopupCancel('PopupCancel')  - Shows Cancelled button    
sg.PopupOKCancel('PopupOKCancel')  - Shows OK and Cancel buttons    
sg.PopupError('PopupError')  - Shows red error button    
sg.PopupTimed('PopupTimed')  - Automatically closes    
sg.PopupAutoClose('PopupAutoClose')  - Same as PopupTimed
</code></pre>
<p><img alt="snap0256" src="https://user-images.githubusercontent.com/13696193/44957394-1380ab00-aea0-11e8-98b1-1ab7d7bd5b37.jpg" />      </p>
<p><img alt="snap0257" src="https://user-images.githubusercontent.com/13696193/44957400-167b9b80-aea0-11e8-9d42-2314f24e62de.jpg" />      </p>
<p><img alt="snap0258" src="https://user-images.githubusercontent.com/13696193/44957399-154a6e80-aea0-11e8-9580-e716f839d400.jpg" />      </p>
<p><img alt="snap0259" src="https://user-images.githubusercontent.com/13696193/44957398-14b1d800-aea0-11e8-9e88-c2b36a248447.jpg" />      </p>
<p><img alt="snap0260" src="https://user-images.githubusercontent.com/13696193/44957397-14b1d800-aea0-11e8-950b-6d0b4f33841a.jpg" />      </p>
<p><img alt="snap0261" src="https://user-images.githubusercontent.com/13696193/44957396-14194180-aea0-11e8-8eef-bb2e1193ecfa.jpg" />      </p>
<p><img alt="snap0264" src="https://user-images.githubusercontent.com/13696193/44957595-9e15da00-aea1-11e8-8909-6b6121b74509.jpg" />      </p>
<pre><code>Popup(*args,  Variable number of arguments you want to display    
    button_color=None, Color of buttons (text_color, background_color)    
    background_color=None, Color of background    
    text_color=None, Color of text    
    button_type=POPUP_BUTTONS_OK, Type of button layout    
    auto_close=False, If True window will automatically close    
    auto_close_duration=None, Number of seconds for autoclose    
    non_blocking=False, If True returns immediately    
    icon=DEFAULT_WINDOW_ICON, Icon to use on the taskbar    
    line_width=None, Width of lines in characters    
    font=None, Font to use for characters    
    no_titlebar=False, If True no titlebar will be shown    
    grab_anywhere=False, If True can move window by grabbing anywhere    
    keep_on_top=False, If True window will be on top of other windows    
    location=(None,None)): (x,y) coordinates to show the window
</code></pre>
<p>The other output Popups are variations on parameters.  Usually the button_type parameter is the primary one changed.      </p>
<p>The choices for button_type are:    </p>
<pre><code>POPUP_BUTTONS_YES_NO    
POPUP_BUTTONS_CANCELLED    
POPUP_BUTTONS_ERROR    
POPUP_BUTTONS_OK_CANCEL    
POPUP_BUTTONS_OK    
POPUP_BUTTONS_NO_BUTTONS    
</code></pre>

<p>Note that you should not call Popup yourself with different button_types.  Rely on the Popup function named that sets that value for you.  For example PopupYesNo will set the button type to POPUP_BUTTONS_YES_NO for you.    </p>
<h4 id="scrolled-output">Scrolled Output</h4>
<p>There is a scrolled version of Popups should you have a lot of information to display.      </p>
<pre><code class="python">PopupScrolled(*args, button_color=None, yes_no=False, auto_close=False, auto_close_duration=None, size=(None, None), location=(None, None), title=None, non_blocking=False)
</code></pre>

<p>Typical usage:</p>
<pre><code>sg.PopupScrolled(my_text)
</code></pre>
<p><img alt="scrolledtextbox 2" src="https://user-images.githubusercontent.com/13696193/43667324-712aa0d4-9745-11e8-83a9-a0d0570d0865.jpg" />      </p>
<p>The <code>PopupScrolled</code> will auto-fit the window size to the size of the text.  Specify <code>None</code> in the height field of a <code>size</code> parameter to get auto-sized height.      </p>
<p>This call will create a scrolled box 80 characters wide and a height dependent upon the number of lines of text.      </p>
<p>sg.PopupScrolled(my_text, size=(80, None))      </p>
<p>Note that the default max number of lines before scrolling happens is set to 50. At 50 lines the scrolling will begin.     </p>
<p>If <code>non_blocking</code> parameter is set, then  the call will not blocking waiting for the user to close the window.  Execution will immediately return to the user.  Handy when you want to dump out debug info without disrupting the program flow.</p>
<h3 id="popupnowait">PopupNoWait</h3>
<p>The Popup call PopupNoWait or PopupNonBlocking will create a popup window and then immediately return control back to you.  All other popup functions will block, waiting for the user to close the popup window.      </p>
<p>This function is very handy for when you're <strong>debugging</strong> and want to display something as output but don't want to change the programs's overall timing by blocking.  Think of it like a <code>print</code> statement. There are no return values on one of these Popups.    </p>
<h2 id="popup-input">Popup Input</h2>
<p>There are Popup calls for single-item inputs. These follow the pattern of <code>Popup</code> followed by <code>Get</code> and then the type of item to get.  There are 3 of these input Popups to choose from, each with settings enabling customization.    </p>
<ul>
<li><code>PopupGetText</code> - get a single line of text      </li>
<li><code>PopupGetFile</code> - get a filename      </li>
<li><code>PopupGetFolder</code> - get a folder name      </li>
</ul>
<p>Use these Popups instead of making  a custom window to get one data value, call the Popup input function to get the item from the user.  If you find the parameters are unable to create the kind of window you are looking for, then it's time for you to create your own window.    </p>
<h3 id="popupgettext">PopupGetText</h3>
<p>Use this Popup to get a line of text from the user.    </p>
<pre><code>PopupGetText(message,The message you wish to display with the input field    
           default_text='', Text to initially fill into the input field    
           password_char='', Passwork character if this is a password field    
           size=(None,None), Size of the window    
           button_color=None, Color to use for buttons (foreground, background)    
           background_color=None, Background color for window    
           text_color=None, Text color for window    
           icon=DEFAULT_WINDOW_ICON, Icon to display on taskbar    
           font=None, Font to use for text    
           no_titlebar=False, If True no titlebar will be shown    
           grab_anywhere=False, If True can grab anywhere to move the window    
           keep_on_top=False, If True window will stay on top of other windows    
           location=(None,None))  Location on screen to display window    
</code></pre>

<pre><code>import PySimpleGUI as sg

text = sg.PopupGetText('Title', 'Please input something')      
sg.Popup('Results', 'The value returned from PopupGetText', text)
</code></pre>
<p><img alt="popupgettext" src="https://user-images.githubusercontent.com/13696193/44957281-8721b880-ae9e-11e8-98cd-d06369f4187e.jpg" />      </p>
<p><img alt="popup gettext response" src="https://user-images.githubusercontent.com/13696193/44957282-8721b880-ae9e-11e8-84ae-dc8bb30504a0.jpg" />      </p>
<h3 id="popupgetfile">PopupGetFile</h3>
<p>Gets a filename from the user.  There are options to configure the type of dialog box to show.  Normally an "Open File" dialog box is shown    </p>
<pre><code>PopupGetFile(message, Message to show in the window    
          default_path='', Path browsing should start from    
          default_extension='', Which filetype is the default    
          save_as=False, Determines which dialog box stype to show    
          file_types=((&quot;ALL Files&quot;, &quot;*.*&quot;),), Which filetypes are displayed    
          no_window=False, if True no window is displayed except the dialog box    
          size=(None,None), Size of window    
          button_color=None, Color of buttons    
          background_color=None, Color of window background    
          text_color=None, Color of text in window    
          icon=DEFAULT_WINDOW_ICON, Icon to show on taskbar    
          font=None, Font to use    
          no_titlebar=False, If True does not display a titlebar    
          grab_anywhere=False, if True can grab window anywhere to move it    
          keep_on_top=False, if True window will be on top of others    
          location=(None,None)) Location on screen to show window    
</code></pre>

<p>If configured as an Open File Popup then (save_as is not True)  the dialog box will look like this    </p>
<p><img alt="snag-0060" src="https://user-images.githubusercontent.com/13696193/46761050-9831c680-cca1-11e8-8de9-68b15efe2c46.jpg" />    </p>
<p>If you set the parameter save_As to True, then the dialog box looks like this:    </p>
<p><img alt="snag-0061" src="https://user-images.githubusercontent.com/13696193/46761330-2b6afc00-cca2-11e8-953b-f6b5c5ce57f5.jpg" />    </p>
<p>If you choose a filename that already exists, you'll get a warning popup box asking if it's OK.  You can also specify a file that doesn't exist.  With an "Open" dialog box you cannot choose a non-existing file.    </p>
<p>A typical call produces this window.    </p>
<pre><code>text = sg.PopupGetFile('Please enter a file name')      
sg.Popup('Results', 'The value returned from PopupGetFile', text)
</code></pre>
<p><img alt="popupgetfile" src="https://user-images.githubusercontent.com/13696193/44957857-2fd31680-aea5-11e8-8eb7-f6b91c202cc8.jpg" />      </p>
<h3 id="popupgetfolder">PopupGetFolder</h3>
<p>The window created to get a folder name looks the same as the get a file name.  The difference is in what the browse button does.  <code>PopupGetFile</code> shows an Open File dialog box while <code>PopupGetFolder</code>  shows an Open Folder dialog box.      </p>
<pre><code>PopupGetFolder(message,  Message to display in window    
            default_path='',  Path to start browsing    
            no_window=False,  If True no window will be shown    
            size=(None,None), Size of window    
            button_color=None, Color of buttons    
            background_color=None, Background color of window    
            text_color=None,  Color of window text    
            icon=DEFAULT_WINDOW_ICON, Icon to show on taskbar    
            font=None,  Font to use for window    
            no_titlebar=False,  If True no titlebar will be shown    
            grab_anywhere=False,  If True can grab anywhere on window to move    
            keep_on_top=False,  If True window will be on top    
            location=(None, None))  Location on screen to create window    
</code></pre>

<p>This is a typpical call    </p>
<pre><code>text = sg.PopupGetFolder('Please enter a folder name')      
sg.Popup('Results', 'The value returned from PopupGetFolder', text)
</code></pre>
<p><img alt="popupgetfolder" src="https://user-images.githubusercontent.com/13696193/44957861-45484080-aea5-11e8-926c-cf607a45251c.jpg" />      </p>
<h3 id="popupanimated">PopupAnimated</h3>
<p><img alt="ring" src="https://user-images.githubusercontent.com/13696193/51296743-6ee4ad00-19eb-11e9-91f5-cd8086ad1b50.gif" /></p>
<p>The animated Popup enables you to easily display a "loading" style animation specified through a GIF file that is either stored in a file or a base64 variable.</p>
<pre><code class="python">def PopupAnimated(image_source, 
                  message=None,
                  background_color=None, 
                  text_color=None, 
                  font=None, 
                  no_titlebar=True, 
                  grab_anywhere=True, 
                  keep_on_top=True, 
                  location=(None, None), 
                  alpha_channel=.8,
                  time_between_frames=0)
</code></pre>

<p>image_source - The GIF file specified as a string filename or a base64 variable
message - optional text message to be displayed under the animation
background_color - the background color to use for the window and all of the other parts of the window
text_color - color to use for optional text
font - font to use for the optional text
no_titlebar - no titlebar window setting
location - location to show the window
alpha_channel - alpha channel to use for the window
time_between_frames - amount of time in milliseconds to use between frames</p>
<p><strong><em>To close animated popups</em></strong>, call PopupAnimated with <code>image_source=None</code>.  This will close all of the currently open PopupAnimated windows.</p>
<h1 id="progress-meters">Progress Meters!</h1>
<p>We all have loops in our code.  'Isn't it joyful waiting, watching a counter scrolling past in a text window?  How about one line of code to get a progress meter, that contains statistics about your code?      </p>
<pre><code>OneLineProgressMeter(title,      
                  current_value,      
                  max_value,      
                  key,      
                  *args,      
                  orientation=None,      
                  bar_color=DEFAULT_PROGRESS_BAR_COLOR,      
                  button_color=None,      
                  size=DEFAULT_PROGRESS_BAR_SIZE,      
                  border_width=DEFAULT_PROGRESS_BAR_BORDER_WIDTH):
</code></pre>
<p>Here's the one-line Progress Meter in action!      </p>
<pre><code>for i in range(1,10000):      
    sg.OneLineProgressMeter('My Meter', i+1, 10000, 'key','Optional message')
</code></pre>
<p>That line of code resulted in this window popping up and updating.      </p>
<p><img alt="preogress meter" src="https://user-images.githubusercontent.com/13696193/43667625-d47da702-9746-11e8-91e6-e5177883abae.jpg" />      </p>
<p>A meter AND fun statistics to watch while your machine grinds away, all for the price of 1 line of code.    <br />
With a little trickery you can provide a way to break out of your loop using the Progress Meter window.  The cancel button results in a <code>False</code> return value from <code>OneLineProgressMeter</code>.  It normally returns <code>True</code>.      </p>
<p><strong><em>Be sure and add one to your loop counter</em></strong> so that your counter goes from 1 to the max value.  If you do not add one, your counter will never hit the max value.  Instead it will go from 0 to max-1.      </p>
<h1 id="debug-output">Debug Output</h1>
<p>Another call in the 'Easy' families of APIs is <code>EasyPrint</code>.  It will output to a debug window.  If the debug window isn't open, then the first call will open it.  No need to do anything but stick a 'print' call in your code. You can even replace your 'print' calls with calls to EasyPrint by simply sticking the statement      </p>
<pre><code>print = sg.EasyPrint
</code></pre>
<p>at the top of your code.      </p>
<p>There are a number of names for the same EasyPrint function.  <code>Print</code> is one of the better ones to use as it's easy to remember.   It is simply <code>print</code> with a capital P.      </p>
<pre><code>import PySimpleGUI as sg

for i in range(100):      
    sg.Print(i)
</code></pre>
<p><img alt="snap0125" src="https://user-images.githubusercontent.com/13696193/43114979-a696189e-8ecf-11e8-83c7-473fcf0ccc66.jpg" />      </p>
<p>Or if you didn't want to change your code:      </p>
<pre><code>import PySimpleGUI as sg

print=sg.Print      
for i in range(100):      
    print(i)
</code></pre>
<p>Just like the standard print call, <code>EasyPrint</code> supports the <code>sep</code> and <code>end</code> keyword arguments.  Other names that can be used to call <code>EasyPrint</code> include <code>Print</code>, <code>eprint</code>,   If you want to close the window, call the function <code>EasyPrintClose</code>.      </p>
<p>You can change the size of the debug window using the <code>SetOptions</code> call with the <code>debug_win_size</code> parameter.      </p>
<p>There is an option to tell PySimpleGUI to reroute all of your stdout and stderr output to this window.  To do so call EasyPrint with the parameter <code>do_not_reroute_stdout</code> set to True.  After calling it once with this parameter set to True, all future calls to a normal<code>print</code> will go to the debug window.</p>
<p>If you close the debug window it will re-open the next time you Print to it.</p>
<hr />
<h1 id="custom-window-api-calls-your-first-window">Custom window API Calls  (Your First window)</h1>
<p>This is the FUN part of the programming of this GUI.  In order to really get the most out of the API, you should be using an IDE that supports auto complete or will show you the definition of the function.  This will make customizing go  smoother.      </p>
<p>This first section on custom windows is for your typical, blocking, non-persistent window.  By this I mean, when you "show" the window, the function will not return until the user has clicked a button or closed the window.  When this happens, the window will be automatically closed.      </p>
<p>Two other types of windows exist.    <br />
1. Persistent window - rather than closing on button clicks, the show window function returns and the window continues to be visible.  This is good for applications like a chat window.    <br />
2. Asynchronous window - the trickiest of the lot. Great care must be exercised.  Examples are an MP3 player or status dashboard.  Async windows are updated (refreshed) on a periodic basis.      </p>
<p>It's both not enjoyable nor helpful to immediately jump into tweaking each and every little thing available to you.      </p>
<h2 id="the-window-designer">The window Designer</h2>
<p>The good news to newcomers to GUI programming is that PySimpleGUI has a window designer.  Better yet, the window designer requires no training, no downloads, and everyone knows how to use it.      </p>
<p><img alt="gui0_1" src="https://user-images.githubusercontent.com/13696193/44159598-e2257400-a085-11e8-9b02-343e72cc75c3.JPG" />      </p>
<p>It's a manual process, but if you follow the instructions, it will take only a minute to do and the result will be a nice looking GUI.  The steps you'll take are:    <br />
1. Sketch your GUI on paper    <br />
2. Divide your GUI up into rows    <br />
3. Label each Element with the Element name    <br />
4. Write your Python code using the labels as pseudo-code      </p>
<p>Let's take a couple of examples.      </p>
<p><strong>Enter a number</strong>.... Popular beginner programs are often based on a game or logic puzzle that requires the user to enter something, like a number.  The "high-low" answer game comes to mind where you try to guess the number based on high or low tips.      </p>
<p><strong>Step 1- Sketch the GUI</strong>    <br />
<img alt="gui1_1" src="https://user-images.githubusercontent.com/13696193/44160127-6a584900-a087-11e8-8fec-09099a8e16f6.JPG" />      </p>
<p><strong>Step 2 - Divide into rows</strong>      </p>
<p><img alt="gui2_1" src="https://user-images.githubusercontent.com/13696193/44160128-6a584900-a087-11e8-9973-af866fb94c56.JPG" />      </p>
<p>Step 3 - Label elements      </p>
<p><img alt="gui6_1" src="https://user-images.githubusercontent.com/13696193/44160116-64626800-a087-11e8-8b57-671c0461b508.JPG" />      </p>
<p>Step 4 - Write the code    <br />
The code we're writing is the layout of the GUI itself.  This tutorial only focuses on getting the window code written, not the stuff to display it, get results.      </p>
<p>We have only 1 element on the first row, some text.  Rows are written as a "list of elements", so we'll need [  ] to make a list.  Here's the code for row 1      </p>
<pre><code>[ sg.Text('Enter a number') ]
</code></pre>
<p>Row 2 has 1 elements, an input field.      </p>
<pre><code>[ sg.Input() ]
</code></pre>
<p>Row 3 has an OK button      </p>
<pre><code>[ sg.OK() ]
</code></pre>
<p>Now that we've got the 3 rows defined, they are put into a list that represents the entire window.      </p>
<pre><code>layout = [ [sg.Text('Enter a Number')],      
           [sg.Input()],      
           [sg.OK()] ]
</code></pre>
<p>Finally we can put it all together into a program that will display our window.      </p>
<pre><code>import PySimpleGUI as sg

layout = [[sg.Text('Enter a Number')],      
          [sg.Input()],      
          [sg.OK()] ]

event, (number,) = sg.Window('Enter a number example').Layout(layout).Read()

sg.Popup(event, number)
</code></pre>
<h3 id="example-2-get-a-filename">Example 2 - Get a filename</h3>
<p>Let's say you've got a utility you've written that operates on some input file and you're ready to use a GUI to enter than filename rather than the command line.  Follow the same steps as the previous example - draw your window on paper, break it up into rows, label the elements.      </p>
<p><img alt="gui4_1" src="https://user-images.githubusercontent.com/13696193/44160132-6a584900-a087-11e8-862f-7d791a67ee5d.JPG" />    <br />
<img alt="gui5_1" src="https://user-images.githubusercontent.com/13696193/44160133-6af0df80-a087-11e8-9dec-bb4d4c59393d.JPG" />      </p>
<p>Writing the code for this one is just as straightforward.  There is one tricky thing, that browse for a file button.  Thankfully PySimpleGUI takes care of associating it with the input field next to it.  As a result, the code looks almost exactly like the window on the paper.      </p>
<pre><code>import PySimpleGUI as sg

layout = [[sg.Text('Filename')],      
          [sg.Input(), sg.FileBrowse()],      
          [sg.OK(), sg.Cancel()] ]

event, (number,) = sg.Window('Get filename example').Layout(layout).Read()

sg.Popup(event, number)
</code></pre>
<p>Read on for detailed instructions on the calls that show the window and return your results.      </p>
<h1 id="copy-these-design-patterns">Copy these design patterns!</h1>
<p>All of your PySimpleGUI programs will utilize one of these 2 design patterns depending on the type of window you're implementing.      </p>
<h2 id="pattern-1-one-shot-window-read-into-list-or-dictionary-the-most-common-pattern">Pattern 1 - "One-shot Window" - Read into list or dictionary (<strong>The Most Common</strong> Pattern)</h2>
<p>This will be the most common pattern you'll follow if you are not using an "event loop" (not reading the window multiple times).  The window is read and closes.</p>
<p>It's unusual to assign the values returned from the read call directly into user variables.  Usually the variables are grouped together into a list or dictionary of multiple return values.    </p>
<pre><code class="python">import PySimpleGUI as sg      

window_rows = [[sg.Text('SHA-1 and SHA-256 Hashes for the file')],      
                 [sg.InputText(), sg.FileBrowse()],      
                 [sg.Submit(), sg.Cancel()]]      

window = sg.Window('SHA-1 &amp; 256 Hash').Layout(window_rows)    

event, values = window.Read()    
window.Close()

source_filename = values[0]    
</code></pre>

<h2 id="pattern-2-a-persistent-window-multiple-reads-using-an-event-loop">Pattern 2 A - Persistent window (multiple reads using an event loop)</h2>
<p>Some of the more advanced programs operate with the window remaining visible on the screen.  Input values are collected, but rather than closing the window, it is kept visible acting as a way to both output information to the user and gather input data.      </p>
<p>This code will present a window and will print values until the user clicks the exit button or closes window using an X.    </p>
<pre><code class="python">import PySimpleGUI as sg      

layout = [[sg.Text('Persistent window')],      
          [sg.Input(do_not_clear=True)],      
          [sg.Button('Read'), sg.Exit()]]      

window = sg.Window('Window that stays open').Layout(layout)      

while True:      
    event, values = window.Read()      
    if event is None or event == 'Exit':      
        break      
    print(event, values)    

window.Close()
</code></pre>

<h2 id="pattern-2-b-persistent-window-multiple-reads-using-an-event-loop-updates-data-in-window">Pattern 2 B - Persistent window (multiple reads using an event loop + updates data in window)</h2>
<p>This is a slightly more complex, but maybe more realistic version that reads input from the user and displays that input as text in the window.  Your program is likely to be doing both of those activities so this will give you a big jump-start.</p>
<p>Do not worry yet what all of these statements mean.   Just copy it so you can begin to play with it, make some changes.  Experiment to see how thing work.</p>
<p>A final note... the parameter <code>do_not_clear</code> in the input call determines the action of the input field after a button event.  If this value is True, the input value remains visible following button clicks.  If False, then the input field is CLEARED of whatever was input.  If you are building a "Form" type of window with data entry, you likely want False, the default setting (you can remove the parameter completely).</p>
<pre><code class="python">import sys  
if sys.version_info[0] &gt;= 3:  
    import PySimpleGUI as sg  
else:  
    import PySimpleGUI27 as sg  

layout = [[sg.Text('Your typed chars appear here:'), sg.Text('', key='_OUTPUT_') ],  
          [sg.Input(do_not_clear=True, key='_IN_')],  
          [sg.Button('Show'), sg.Button('Exit')]]  

window = sg.Window('Window Title').Layout(layout)  

while True:                 # Event Loop  
  event, values = window.Read()  
  print(event, values)
  if event is None or event == 'Exit':  
      break  
  if event == 'Show':  
      # change the &quot;output&quot; element to be the value of &quot;input&quot; element  
      window.FindElement('_OUTPUT_').Update(values['_IN_'])

window.Close()
</code></pre>

<h2 id="how-gui-programming-in-python-should-look-at-least-for-beginners">How GUI Programming in Python Should Look?  At least for beginners ?</h2>
<p>While one goal was making it simple to create a GUI another just as important goal was to do it in a Pythonic manner. Whether it achieved these goals is debatable, but it was an attempt just the same.      </p>
<p>The key to custom windows in PySimpleGUI is to view windows as ROWS of GUI  Elements.  Each row is specified as a list of these Elements.  Put the rows together and you've got a window.  This means the GUI is defined as a series of Lists, a Pythonic way of looking at things.    </p>
<p>Let's dissect this little program   <br />
 ```python  <br />
    import PySimpleGUI as sg      </p>
<pre><code>layout = [[sg.Text('Rename files or folders')],      
          [sg.Text('Source for Folders', size=(15, 1)), sg.InputText(), sg.FolderBrowse()],      
          [sg.Text('Source for Files ', size=(15, 1)), sg.InputText(), sg.FolderBrowse()],      
          [sg.Submit(), sg.Cancel()]]

window = sg.Window('Rename Files or Folders')

event, values = window.Layout(layout).Read()
</code></pre>
<p>```    </p>
<p><img alt="snap0131" src="https://user-images.githubusercontent.com/13696193/43417007-df6d8408-9407-11e8-9986-30f0415f08a5.jpg" />      </p>
<p>Let's agree the window has 4 rows.      </p>
<p>The first row only has <strong>text</strong> that reads <code>Rename files or folders</code>      </p>
<p>The second row has 3 elements in it.  First the <strong>text</strong> <code>Source for Folders</code>, then an <strong>input</strong> field, then a <strong>browse</strong> button.      </p>
<p>Now let's look at how those 2 rows and the other two row from Python code:      </p>
<pre><code>layout = [[sg.Text('Rename files or folders')],      
          [sg.Text('Source for Folders', size=(15, 1)), sg.InputText(), sg.FolderBrowse()],      
          [sg.Text('Source for Files ', size=(15, 1)), sg.InputText(), sg.FolderBrowse()],      
          [sg.Submit(), sg.Cancel()]]
</code></pre>
<p>See how the source code mirrors the layout?  You simply make lists for each row, then submit that table to PySimpleGUI to show and get values from.      </p>
<p>And what about those return values?  Most people simply want to show a window, get the input values and do something with them.  So why break up the code into button callbacks, etc, when I simply want my window's input values to be given to me.      </p>
<p>For return values the window is scanned from top to bottom, left to right.  Each field that's an input field will occupy a spot in the return values.      </p>
<p>In our example window, there are 2 fields, so the return values from this window will be a list with 2 values in it.    <br />
<code>python    
  event, values = window.Read()    
  folder_path, file_path = values</code>    </p>
<p>In one statement we both show the window and read the user's inputs.  In the next the <em>list</em> of return values is split into individual variables <code>folder_path</code> and <code>file_path</code>.    </p>
<p>Isn't this what a Python programmer looking for a GUI wants? Something easy to work with to get the values and move on to the rest of the program, where the real action is taking place.  Why write pages of GUI code when the same layout can be achieved with PySimpleGUI in 3 or 4 lines of code.  4 lines or 40?  Most would choose 4.    </p>
<h2 id="return-values">Return values</h2>
<p>As of version 2.8 there are 2 forms of return values, list and dictionary.   </p>
<h3 id="two-return-values">Two Return Values</h3>
<p>All Window Read calls return 2 values.  By convention a read statement is written:  </p>
<pre><code class="python">event, values = window.Read()      
</code></pre>

<p>You don't HAVE to write your reads in this way. You can name your variables however you want.  But if you want to code them in a way that other programmers using PySimpleGUI are used to, then use these statements.  </p>
<h2 id="events">Events</h2>
<p>The first parameter <code>event</code> describes <strong>why</strong> the read completed.  Events are one of these:  </p>
<p>For all Windows:  </p>
<ul>
<li>Button click  </li>
<li>Window closed using X  </li>
</ul>
<p>For Windows that have specifically enabled these.  Please see the appropriate section in this document to learn about how to enable these and what the event return values are.  </p>
<ul>
<li>Keyboard key press  </li>
<li>Mouse wheel up/down  </li>
<li>Menu item selected  </li>
<li>An Element Changed (slider, spinner, etc)  </li>
<li>A list item was clicked  </li>
<li>Return key was pressed in input element  </li>
<li>Timeout waiting for event</li>
<li>Text was clicked</li>
<li>Combobox item chosen</li>
<li>Table row selected</li>
<li>etc</li>
</ul>
<p><strong><em>Most</em></strong> of the time the event will be a button click or the window was closed.  </p>
<h3 id="window-closed-event">Window closed event</h3>
<p>Another convention to follow is the check for windows being closed with an X.  This is an important event to catch.  If you don't check for this and you attempt to use the window, your program will crash.  Please check for closed window and exit your program gracefully.  </p>
<p>To check for a closed window use this line of code:  </p>
<pre><code>if event is None:
</code></pre>
<p>Putting it all together we end up with an "event loop" that looks something like this:</p>
<pre><code class="python">while True:
    event, values = window.Read()
    if event is None:
        break
</code></pre>

<h3 id="button-click-events">Button Click Events</h3>
<p>By default buttons will always return a click event, or in the case of realtime buttons, a button down event.  You don't have to do anything to enable button clicks.  To disable the events, disable the button using its Update method.</p>
<p>You can enable an additional "Button Modified" event by setting <code>enable_events=True</code> in the Button call.  These events are triggered when something 'writes' to a button, <strong><em>usually</em></strong> it's because the button is listed as a "target" in another button.</p>
<p>The button value from a Read call will be one of 2 values:    <br />
1. The Button's text      - Default
2. The Button's key      - If a key is specified</p>
<p>If a button has a key set when it was created, then that key will be returned.  If no key is set, then the button text is returned.  If no button was clicked, but the window returned anyway, the event value is None.      </p>
<h3 id="none-is-returned-when-the-user-clicks-the-x-to-close-a-window"><strong>None is returned when the user clicks the X to close a window.</strong></h3>
<p>If your window has an event loop where it is read over and over, remember to give your user an "out".  You should <strong><em>always check for a None value</em></strong> and it's a good practice to provide an Exit button of some kind. Thus design patterns often resemble this Event Loop:      </p>
<pre><code>while True:      
    event, values = window.Read()      
    if event is None or event == 'Quit':      
        break
</code></pre>
<h3 id="element-events">Element Events</h3>
<p>Some elements are capable of generating events when something happens to them.  For example, when a slider is moved, or list item clicked on or table row clicked on.  These events are not enabled by default.  To enable events for an Element, set the parameter <code>enable_events=True</code>.  This is the same as the older <code>click_submits</code> parameter.  You will find the <code>click_submits</code> parameter still in the function definition.  You can continue to use it. They are the same setting.  An 'or' of the two values is used.  In the future, click_submits will be removed so please migrate your code to using <code>enable_events</code>.</p>
<p>InputText - any change
Combo - item chosen
Option menu - item chosen
Listbox - selection changed
Radio - selection changed
Checkbox - selection changed
Spinner - new item selected
Multiline - any change
Text - clicked
Status Bar - clicked
Graph - clicked
TabGroup - tab clicked
Slider - slider moved
Table - row selected
Tree - node selected
ButtonMenu - menu item chosen
Right click menu - menu item chosen</p>
<h3 id="other-events">Other Events</h3>
<h4 id="menubar-menu-item-chosen-for-menubar-menus-and-buttonmenu-menus">Menubar menu item chosen for MenuBar menus and ButtonMenu menus</h4>
<p>You will receive the key for the MenuBar and ButtonMenu.  Use that key to read the value in the return values dictionary.  The value shown will be the full text plus key for the menu item chosen.  Remember that you can put keys onto menu items.  You will get the text and the key together as you defined it in the menu
 definition.</p>
<h4 id="right-click-menu-item-chosen">Right Click menu item chosen</h4>
<p>Unlike menu bar and button menus, you will directly receive the menu item text and its key value.  You will not do a dictionary lookup to get the value.  It is the event code returned from WindowRead().</p>
<h4 id="windows-keyboard-mouse-scroll-wheel">Windows - keyboard, mouse scroll wheel</h4>
<p>Windows are capable of returning keyboard events.  These are returned as either a single character or a string if it's a special key.  Experiment is all I can say. The mouse scroll wheel events are also strings.  Put a print in your code to see what's returned.</p>
<h4 id="timeouts">Timeouts</h4>
<p>If you set a timeout parameter in your read, then the system TIMEOUT_KEY will be returned.  If you specified your own timeout key in the Read call then that value will be what's returned instead.</p>
<h3 id="the-values-variable-return-values-as-a-list">The <code>values</code> Variable - Return values as a list</h3>
<p>The second parameter from a Read call is either a list or a dictionary of the input fields on the Window.  </p>
<p>By default return values are a list of values, one entry for each input field.      </p>
<p>Each of the Elements that are Input Elements will have a value in the list of return values.  You can unpack your GUI directly into the variables you want to use.      </p>
<pre><code>event, (filename, folder1, folder2, should_overwrite) = sg.Window('My title').Layout(window_rows).Read()
</code></pre>
<p>Or, more commonly, you can unpack the return results separately.      </p>
<pre><code class="python">event, values = sg.Window('My title').Layout(window_rows).Read()    
event, value_list = window.Layout(window_rows).Read()      
value1 = value_list[0]      
value2 = value_list[1]      
     ...     
</code></pre>

<p>However, this method isn't good when you have a lot of input fields.  If you insert a new element into your window then you will have to shuffle your unpacks down, modifying each of the statements to reference <code>value_list[x]</code>.  </p>
<p>The more common / advanced method is to request your values be returned as a dictionary.  </p>
<h3 id="values-variable-return-values-as-a-dictionary"><code>values</code> Variable - Return values as a dictionary</h3>
<p>For those of you that have not encountered a Python dictionary, don't freak out!  Just copy and paste the sample code and modify it. Follow this design pattern and you'll be fine.  And you might learn something along the way.  </p>
<p>For windows longer than 3 or 4 fields you will want to use a dictionary to help you organize your return values. In almost all (if not all) of the demo programs you'll find the return values being passed as a dictionary.  It is not a difficult concept to grasp, the syntax is easy to understand, and it makes for very readable code.      </p>
<p>The most common window read statement you'll encounter looks something like this:      </p>
<p>window = sg.Window("My title").Layout(layout).Read()    </p>
<p>To use a dictionary, you will need to:    <br />
 * Mark each input element you wish to be in the dictionary with the keyword <code>key</code>.      </p>
<p>If <strong>any</strong> element in the window has a <code>key</code>, then <strong>all</strong> of the return values are returned via a dictionary.  If some elements do not have a key, then they are numbered starting at zero.      </p>
<p>Let's take a look at your first dictionary-based window.      </p>
<pre><code>import PySimpleGUI as sg      
window = sg.Window('Simple data entry window')      
layout = [      
          [sg.Text('Please enter your Name, Address, Phone')],      
          [sg.Text('Name', size=(15, 1)), sg.InputText('1', key='_name_')],      
          [sg.Text('Address', size=(15, 1)), sg.InputText('2', key='_address_')],      
          [sg.Text('Phone', size=(15, 1)), sg.InputText('3', key='_phone_')],      
          [sg.Submit(), sg.Cancel()]      
         ]

event, values = window.Layout(layout).Read()

sg.Popup(event, values, values['_name_'], values['_address_'], values['_phone_'])
</code></pre>
<p>To get the value of an input field, you use whatever value used as the <code>key</code> value as the index value.  Thus to get the value of the name field, it is written as      </p>
<pre><code>values['name']
</code></pre>
<p>Think of the variable values in the same way as you would a list, however, instead of using 0,1,2, to reference each item in the list, use the values of the key.  The Name field in the window above is referenced by <code>values['_name_']</code>.    </p>
<p>You will find the key field used quite heavily in most PySimpleGUI windows unless the window is very simple.      </p>
<p>Another  convention you'll see in some of the demo programs is keys being named with an underscore at the beginning and the end.  You don't HAVE to do this... your key value may look like this:<br />
<code>key = 'name'</code>  </p>
<p>The reason for this naming convention is that when you are scanning the code, these key values jump out at you.   You instantly know it's a key.  Try scanning the code above and see if those keys pop out.<br />
<code>key = '_name_'</code>  </p>
<h2 id="the-event-loop-callback-functions">The Event Loop / Callback Functions</h2>
<p>All GUIs have one thing in common, an "event loop".  Usually the GUI framework runs the event loop for you, but sometimes you want greater control and will run your own event loop.  You often hear the term event loop when discussing embedded systems or on a Raspberry Pi.      </p>
<p>With PySimpleGUI if your window will remain open following button clicks, then your code will have an event loop. If your program shows a single "one-shot"  window, collects the data and then has no other GUI interaction, then you don't need an event loop.    </p>
<p>There's nothing mysterious about event loops... they are loops where you take care of.... wait for it..... <em>events</em>.  Events are things like button clicks, key strokes, mouse scroll-wheel up/down.        </p>
<p>Let's take a Pi demo program as an example.  This program shows a GUI window, gets button presses, and uses them to control some LEDs.  It loops, reading user input and doing something with it.      </p>
<p>This little program has a typical Event Loop      </p>
<p><img alt="readme example" src="https://user-images.githubusercontent.com/13696193/46566965-f4d65f80-c8f6-11e8-91a3-8cebad0cba90.jpg" />    </p>
<pre><code class="python">import PySimpleGUI as sg      

layout = [[sg.Text('Click read to read the input value')],      
          [sg.Input()],      
          [sg.RButton('Read'), sg.Exit()]]      

window = sg.Window('Persistent GUI Window').Layout(layout)      

while True:      
    event, values = window.Read()      
    if event is None or event == 'Exit':      
        break      
    print(event, values)   
window.Close()
</code></pre>

<p>In the Event Loop we are reading the window and then doing a series of button compares to determine what to do  based on the button that was clicks (value of <code>button</code> variable)      </p>
<p>The way buttons are presented to the caller in PySimpleGUI is <strong><em>not</em></strong> how <em>most</em> GUI frameworks handle button clicks.  Most GUI frameworks, including tkinter, use <strong><em>callback</em></strong> functions, a function you define would be called when a button is clicked.  This requires you to write asynchronous code, a concept beginners often stumble on and one that presents a barrier.    </p>
<p>There is a more communications that have to happen between parts of your program when using callbacks.  Callbacks break apart your program's logic apart and scatter it.  One of the larger hurdles for beginners to GUI programming are these callback functions.      </p>
<p>PySimpleGUI was specifically designed in a way so that callbacks would not be required.  There is no coordination between one function and another required.  You simply read your button click and take appropriate action at the same location in the code as when you read the button value.      </p>
<p>Whether or not this is a "proper" design for GUI programs can be debated.  It's not a terrible trade-off to run your own event loop and having a functioning GUI application versus one that maybe never gets written because callback functions were too much to grasp.      </p>
<hr />
<h2 id="all-widgets-elements">All Widgets / Elements</h2>
<p>This code utilizes many of the common Elements.  It does not include Tabs/Tab Groups.    </p>
<pre><code class="python">    import PySimpleGUI as sg      

    sg.ChangeLookAndFeel('GreenTan')      

    # ------ Menu Definition ------ #      
    menu_def = [['File', ['Open', 'Save', 'Exit', 'Properties']],      
                ['Edit', ['Paste', ['Special', 'Normal', ], 'Undo'], ],      
                ['Help', 'About...'], ]      

    # ------ Column Definition ------ #      
    column1 = [[sg.Text('Column 1', background_color='#F7F3EC', justification='center', size=(10, 1))],      
               [sg.Spin(values=('Spin Box 1', '2', '3'), initial_value='Spin Box 1')],      
               [sg.Spin(values=('Spin Box 1', '2', '3'), initial_value='Spin Box 2')],      
               [sg.Spin(values=('Spin Box 1', '2', '3'), initial_value='Spin Box 3')]]      

    layout = [      
        [sg.Menu(menu_def, tearoff=True)],      
        [sg.Text('All graphic widgets in one window!', size=(30, 1), justification='center', font=(&quot;Helvetica&quot;, 25), relief=sg.RELIEF_RIDGE)],      
        [sg.Text('Here is some text.... and a place to enter text')],      
        [sg.InputText('This is my text')],      
        [sg.Frame(layout=[      
        [sg.Checkbox('Checkbox', size=(10,1)),  sg.Checkbox('My second checkbox!', default=True)],      
        [sg.Radio('My first Radio!     ', &quot;RADIO1&quot;, default=True, size=(10,1)), sg.Radio('My second Radio!', &quot;RADIO1&quot;)]], title='Options',title_color='red', relief=sg.RELIEF_SUNKEN, tooltip='Use these to set flags')],      
        [sg.Multiline(default_text='This is the default Text should you decide not to type anything', size=(35, 3)),      
         sg.Multiline(default_text='A second multi-line', size=(35, 3))],      
        [sg.InputCombo(('Combobox 1', 'Combobox 2'), size=(20, 1)),      
         sg.Slider(range=(1, 100), orientation='h', size=(34, 20), default_value=85)],      
        [sg.InputOptionMenu(('Menu Option 1', 'Menu Option 2', 'Menu Option 3'))],      
        [sg.Listbox(values=('Listbox 1', 'Listbox 2', 'Listbox 3'), size=(30, 3)),      
         sg.Frame('Labelled Group',[[      
         sg.Slider(range=(1, 100), orientation='v', size=(5, 20), default_value=25),      
         sg.Slider(range=(1, 100), orientation='v', size=(5, 20), default_value=75),      
         sg.Slider(range=(1, 100), orientation='v', size=(5, 20), default_value=10),      
         sg.Column(column1, background_color='#F7F3EC')]])],      
        [sg.Text('_'  * 80)],      
        [sg.Text('Choose A Folder', size=(35, 1))],      
        [sg.Text('Your Folder', size=(15, 1), auto_size_text=False, justification='right'),      
         sg.InputText('Default Folder'), sg.FolderBrowse()],      
        [sg.Submit(tooltip='Click to submit this window'), sg.Cancel()]      
    ]      


    window = sg.Window('Everything bagel', default_element_size=(40, 1), grab_anywhere=False).Layout(layout)      

    event, values = window.Read()      

    sg.Popup('Title',      
             'The results of the window.',      
             'The button clicked was &quot;{}&quot;'.format(event),      
             'The values are', values)      
</code></pre>

<p>This is a somewhat complex window with quite a bit of custom sizing to make things line up well.  This is code you only have to write once.  When looking at the code, remember that what you're seeing is a list of lists.  Each row contains a list of Graphical Elements that are used to create the window.      </p>
<p><img alt="everything bagel" src="https://user-images.githubusercontent.com/13696193/45914128-87163800-be0e-11e8-9a83-7ee5960e88b9.jpg" />      </p>
<p>Clicking the Submit button caused the window call to return.  The call to Popup resulted in this window.      </p>
<p><img alt="everything bagel reseults" src="https://user-images.githubusercontent.com/13696193/45914129-87aece80-be0e-11e8-8aae-9a483a9ad4a6.jpg" />      </p>
<p><strong><code>Note, button value can be None</code></strong>.  The value for <code>button</code> will be the text that is displayed on the button element when it was created.  If the user closed the window using something other than a button, then <code>button</code> will be <code>None</code>.   It is <strong><em>vitally</em></strong> <strong><em>important</em></strong> that your code contain the proper checks for None.  Always give your users a way out of the window.  Otherwise you'll end up  with windows that never properly close.    </p>
<p>You can see in the results Popup window that the values returned are a list.  Each input field in the window generates one item in the return values list.  All input fields return a <code>string</code> except for Check Boxes and Radio Buttons.  These return <code>bool</code>.      </p>
<hr />
<h1 id="building-custom-windows">Building Custom Windows</h1>
<p>You will find it <strong><em>much easier</em></strong> to write code using PySimpleGUI if you use an IDE such as PyCharm.  The features that show you documentation about the API call you are making will help you determine which settings you want to change, if any.  In PyCharm, two commands are particularly helpful.      </p>
<pre><code>Control-Q (when cursor is on function name) brings up a box with the function definition      
Control-P (when cursor inside function call "()") shows a list of parameters and their default values
</code></pre>
<h2 id="synchronous-windows">Synchronous windows</h2>
<p>The most common use of PySimpleGUI is to display and collect information from the user.  The most straightforward way to do this is using a "blocking" GUI call.  Execution is "blocked" while waiting for the user to close the GUI window/dialog box.    <br />
You've already seen a number of examples above that use blocking windows.  A truly non-blocking Read call looks like this:</p>
<pre><code class="python">event, values = window.Read(timeout=0)
</code></pre>

<p>You can learn more about these async / non-blocking windows toward the end of this document.    </p>
<h1 id="window-object-beginning-a-window">Window Object - Beginning a window</h1>
<p>The first step is to create the window object using the desired window customization.      </p>
<p>This is the definition of the Window object:      </p>
<pre><code class="python">Window( title, 
        default_element_size=DEFAULT_ELEMENT_SIZE,
        default_button_element_size=(None,None),
        auto_size_text=None,
        auto_size_buttons=None,
        location=(None,None),
        size=(None,None),
        element_padding=None,
        button_color=None,
        font=None,
        progress_bar_color=(None,None),
        background_color=None,
        border_depth=None,
        auto_close=False,
        auto_close_duration=DEFAULT_AUTOCLOSE_TIME,
        icon=DEFAULT_WINDOW_ICON,
        force_toplevel=False,
        alpha_channel=1,
        return_keyboard_events=False,
        use_default_focus=True,
        text_justification=None,
        no_titlebar=False,
        grab_anywhere=False,
        keep_on_top=False,
        resizable=False,
        disable_close=False,
        disable_minimize=False,
        right_click_menu=None):     
</code></pre>

<p>Parameter Descriptions.  You will find these same parameters specified for each <code>Element</code> and some of them in <code>Row</code> specifications.  The <code>Element</code> specified value will take precedence over the <code>Row</code> and <code>window</code> values.      </p>
<pre><code>   default_element_size - Size of elements in window in characters (width, height)      
   default_button_element_size - Size of buttons on this window      
   auto_size_text - Bool. True if elements should size themselves according to contents. Defaults to True      
   auto_size_buttons - Bool. True if button elements should size themselves according to their text label      
   location - (x,y) Location to place window in pixels  
   size - (w,h) forces a window to be a paricular size
   element_padding - (w,h) default padding amount for elements
   font - Font name and size for elements of the window      
   button_color - Default color for buttons (foreground, background). Can be text or hex      
   progress_bar_color - Foreground and background colors for progress bars      
   background_color - Color of the window background      
   border_depth - Amount of 'bezel' to put on input boxes, buttons, etc.      
   auto_close - Bool.  If True window will autoclose      
   auto_close_duration - Duration in seconds before window closes      
   icon - .ICO file that will appear on the Task Bar and end of Title Bar      
   force_top_level - Bool. If set causes a tk.Tk window to be used as primary window rather than tk.TopLevel. Used to get around Matplotlib problem    
   alpha_channel - Float 0 to 1. 0 is invisible, 1 is fully visible, Anything between will be semi-transparent 
   return_keyboard_events - if True key presses are returned as buttons      
   use_default_focus - if True and no focus set, then automatically set a focus      
   text_justification - Justification to use for Text Elements in this window      
   no_titlebar - Create window without a titlebar      
   grab_anywhere - Grab any location on the window to move the window      
   keep_on_top - if True then window will always stop on top of other windows on the screen.  Great for floating toolbars.     
   resizable - if True - user can manually changge the wize of the window.  Defaults to False
   disable_close - if True user will not be able to close using the X. 
   disable_minimize - if True user will not be able to minimize the window
   right_click_menu - menu definition that will be used on wall elements that support right click. If a  definition is specified on an element then it will be used instead.
</code></pre>
<h3 id="window-location">Window Location</h3>
<p>PySimpleGUI computes the exact center of your window and centers the window on the screen.  If you want to locate your window elsewhere, such as the system default of (0,0), if you have 2 ways of doing this. The first is when the window is created.  Use the <code>location</code> parameter to set where the window.  The second way of doing this is to use the <code>SetOptions</code> call which will set the default window location for all windows in the future.      </p>
<h3 id="window-size">Window Size</h3>
<p>You can get your window's size by access the <code>Size</code>property.  The window has to be Read once or Finalized in order for the value to be correct. Note that it's a property, not a call.</p>
<p><code>my_windows_size = window.Size</code></p>
<p>To finalize your window:</p>
<pre><code class="pytyhon">window = Window('My Title').Layout(layout).Finalize()
</code></pre>

<h3 id="element-sizes">Element Sizes</h3>
<p>Note several variables that deal with "size".  Element sizes are measured in characters.  A Text Element with a size of 20,1 has a size of 20 characters wide by 1 character tall.      </p>
<p>The default Element size for PySimpleGUI is <code>(45,1)</code>.      </p>
<p>Sizes can be set at the element level, or in this case, the size variables apply to all elements in the window.  Setting <code>size=(20,1)</code> in the window creation call will set all elements in the window to that size.      </p>
<p>There are a couple of widgets where one of the size values is in pixels rather than characters.  This is true for Progress Meters and Sliders.  The second parameter is the 'height' in pixels.      </p>
<h3 id="no-titlebar">No Titlebar</h3>
<p>Should you wish to create cool looking windows that are clean with no windows titlebar, use the no_titlebar option when creating the window.      </p>
<p>Be sure an provide your user an "exit" button or they will not be able to close the window!  When no titlebar is enabled, there will be no icon on your taskbar for the window.  Without an exit button you will need to kill via taskmanager... not fun.      </p>
<p>Windows with no titlebar rely on the grab anywhere option to be enabled or else you will be unable to move the window.      </p>
<p>Windows without a titlebar can be used to easily create a floating launcher.      </p>
<p>Linux users!  Note that this setting has side effects for some of the other Elements.  Multi-line input doesn't work at all, for example  So, use with caution.      </p>
<p><img alt="floating launcher" src="https://user-images.githubusercontent.com/13696193/45258246-71bafb80-b382-11e8-9f5e-79421e6c00bb.jpg" />      </p>
<h3 id="grab-anywhere">Grab Anywhere</h3>
<p>This is a feature unique to PySimpleGUI.      </p>
<p>Note - there is a warning message printed out if the user closes a non-blocking window using a button with grab_anywhere enabled.  There is no harm in these messages, but it may be distressing to the user.    Should you wish to enable for a non-blocking window, simply get grab_anywhere = True when you create the window.      </p>
<h3 id="always-on-top">Always on top</h3>
<p>To keep a window on top of all other windows on the screen, set keep_on_top = True when the window is created.  This feature makes for floating toolbars that are very helpful and always visible on your desktop.      </p>
<h3 id="focus">Focus</h3>
<p>PySimpleGUI will set a default focus location for you.  This generally means the first input field.  You can set the focus to a particular element.  If you are going to set the focus yourself, then you should turn off the automatic focus by setting <code>use_default_focus=False</code> in your Window call.</p>
<h3 id="window-methods-things-you-can-do-with-a-window-object">Window Methods (things you can do with a Window object)</h3>
<p>There are a few methods (functions) that you will see in this document that act on Windows.  The ones you will primarily be calling are:      </p>
<pre><code>window.Layout(layout) - Turns your definition of the Window into Window      
window.Finalize() - creates the tkinter objects for the Window. Normally you do not call this      
window.Read() - Read the Windows values and get the button / key that caused the Read to return. Can have an optional timeout      
window.ReadNonBlocking() - NO LONGER USED!  
window.Refresh() - Use if updating elements and want to show the updates prior to the nex Read      
window.Fill(values_dict) - Fill each Element with entry from the dictionary passed in      
window.SaveToDisk(filename) - Save the Window's values to disk      
window.LoadFromDisk(filename) - Load the Window's values from disk      
window.Close() - To close your window, if a button hasn't already closed it    
window.Disable() - Use to disable the window inputwhen opening another window on top of the primnary  Window      
window.Enable() - Re-enable a Disabled window      
window.FindElement(key, silent_on_error=False) - Returns the element that has a matching key value  
window.Move(x,y) - Moves window to location x,y on screen'
window.SetAlpha(alpha) - Changes window transparency
window.BringToFront() - Brings the window to the top of other windows on the screen
window.Disappear(), Reappear() - Uses alpha channel to make window disappear
window.Hide(), UnHide() - Hides a window
window.CurrentLocation() - Returns current window location
window.Size = w,h - Forces a window to be a particular size. Note this is a property not a method
window.Size - Tuple (w,h)The size of the current window. Note this is a property
window.Minimize() - Minimizes window to taskbar
</code></pre>
<h2 id="window-methods">Window Methods</h2>
<p>There are a number of operations you can do on a window after you've created the window.  You call these after creating your Windows object.    </p>
<h4 id="layoutrows">Layout(rows)</h4>
<p>Call to set the window layout.  Must be called prior to Read.  Most likely "chained" in line with the Window creation.    </p>
<pre><code class="python">window = sg.Window('My window title').Layout(layout)    
</code></pre>

<h4 id="finalize">Finalize()</h4>
<p>Call to force a window to go through the final stages of initialization.  This will cause the tkinter resources to be allocated so that they can then be modified.    This also causes your window to appear.  If you do not want your window to appear when Finalize is called, then set the Alpha to 0 in your window's creation parameters.</p>
<p>If you want to call an element's Update method or call a Graph element's drawing primitives, you <strong><em>must</em></strong> either call <code>Read</code> or <code>Finalize</code> prior to making those calls.</p>
<h4 id="readtimeoutnone-timeout_key__timeout_-_">Read(timeout=None, timeout_key='__TIMEOUT_ _ ')</h4>
<p>Read the Window's input values and button clicks in a blocking-fashion    </p>
<p>Returns event, values.  Adding a timeout can be achieved by setting timeout=number of milliseconds before the Read times out after which a "timeout event" is returned.  The value of timeout_key will be returned as the event.   If you do not specify a timeout key, then the value <code>TIMEOUT_KEY</code> will be returned.</p>
<p>If you set the timeout = 0, then the Read will immediately return rather than waiting for input or for a timeout. This is the same as the old ReadNonBlocking call.</p>
<h4 id="readnonblocking-no-longer-used">ReadNonBlocking()    (NO LONGER USED)</h4>
<p>While this call will technically still work, it is being removed.  If you want to get the same result, call Read with timeout = 0.</p>
<p>Read the Window's input values and button clicks but without blocking.  It will immediately return.    <strong>Consider using Read with non-zero timeout instead!</strong></p>
<p>Will consume 100% of your CPU if you do not have other blocking calls in your event loop.</p>
<h4 id="refresh">Refresh()</h4>
<p>Cause changes to the window to be displayed on the screen.  Normally not needed unless the changes are immediately required or if it's going to be a while before another call to Read.    </p>
<h4 id="seticonicon-pngbase64">SetIcon(icon, pngbase64)</h4>
<p>Sets the window's icon that will be shown on the titlebar.    Can either be a filename or a base64 string.</p>
<h4 id="fillvalues_dict">Fill(values_dict)</h4>
<p>Populates the windows fields with the values shown in the dictionary.      </p>
<h4 id="elementkey-silent_on_errorfalse-shorthand-version">Element(key, silent_on_error=False)         (shorthand version)</h4>
<h4 id="findelementkey-silent_on_errorfalse">FindElement(key, silent_on_error=False)</h4>
<p>Returns the Element that has a matching key.  If the key is not found, an Error Element is returned so that the program will not crash should the user try to perform an "update".  A Popup message will be shown    </p>
<h4 id="findelementwithfocus">FindElementWithFocus()</h4>
<p>Returns the Element that currently has the focus.  Returns None if no Elements were found.</p>
<h4 id="savetodiskfilename">SaveToDisk(filename)</h4>
<p>Saves the window's values to disk    </p>
<h4 id="loadfromdiskfilename">LoadFromDisk(filename)</h4>
<p>Fills in a window's fields based on previously saved file    </p>
<h4 id="getscreendimensions">GetScreenDimensions()</h4>
<p>Returns the size (w,h) of the screen in pixels    </p>
<h4 id="currentlocation">CurrentLocation()</h4>
<p>Returns current screen position (x,y) </p>
<h4 id="movex-y">Move(x, y)</h4>
<p>Move window to (x,y) position on the screen</p>
<h4 id="minimize">Minimize()</h4>
<p>Sends the window to the taskbar</p>
<h4 id="close">Close()</h4>
<p>Closes a window, blocking or non-blocking</p>
<h4 id="closenonblocking-no-longer-used-use-close-instead">CloseNonBlocking()    (NO LONGER USED.. use Close instead)</h4>
<p>Closes a non-blocking window    </p>
<h4 id="disable">Disable()</h4>
<p>Stops a window from  responding until Enable is called    </p>
<h4 id="enable">Enable()</h4>
<p>Re-enables a previously disabled window    </p>
<h4 id="hide">Hide()</h4>
<p>Completely hides a window, including removing from the taskbar    </p>
<h4 id="unhide">UnHide()</h4>
<p>Restores a window hidden using Hide    </p>
<h4 id="disappear">Disappear()</h4>
<p>Makes a window disappear while leaving the icon on the taskbar    </p>
<h4 id="reappear">Reappear()</h4>
<p>Makes a window reappear that was previously made to disappear using Disappear()    </p>
<h4 id="setalphaalpha">SetAlpha(alpha)</h4>
<p>Sets the window's transparency.  0 is completely transparent.  1 is fully visible, normal .  Can also use the property Window.AlphaChannel instead of method function call</p>
<h1 id="elements">Elements</h1>
<p>"Elements" are the building blocks used to create windows.  Some GUI APIs use the term "Widget" to describe these graphic elements.      </p>
<pre><code> Text      
 Single Line Input      
 Buttons including these types:      
     File Browse      
     Folder Browse      
     Calendar picker      
     Date Chooser      
     Read window      
     Close window ("Button" &amp; all shortcut buttons)     
     Realtime      
 Checkboxes      
 Radio Buttons      
 Listbox      
 Slider      
 Multi-line Text Input/Output
 Multi-line Text Output (Qt only)   
 Scroll-able Output  
 Vertical Separator    
 Progress Bar      
 Option Menu      
 Menu
 ButtonMenu      
 Frame      
 Column      
 Graph      
 Image      
 Table      
 Tree    
 Tab, TabGroup    
 StatusBar
 Pane
 Stretch (Qt only)
</code></pre>
<h2 id="common-element-parameters">Common Element Parameters</h2>
<p>Some parameters that you  will see on almost all Elements are:      </p>
<ul>
<li>key   -  Used with window.FindElement and with return values    </li>
<li>tooltip   - Hover your mouse over the elemnt and you'll get a popup with this text    </li>
<li>size  - (width, height) - usually measured in characters-wide, rows-high.  Sometimes they mean pixels    </li>
<li>font - specifies the font family, size, etc    </li>
<li>colors - Color name or #RRGGBB string    </li>
<li>pad - Amount of padding to put around element    </li>
<li>enable_events - Turns on the element specific events    </li>
</ul>
<h4 id="tooltip">Tooltip</h4>
<p>Tooltips are text boxes that popup next to an element if you hold your mouse over the top of it.  If you want to be extra kind to your window's user, then you can create tooltips for them by setting the parameter <code>tooltip</code> to some text string.  You will need to supply your own line breaks / text wrapping.  If you don't want to manually add them, then take a look at the standard library package <code>textwrap</code>.      </p>
<p>Tooltips are one of those "polish" items that really dress-up a GUI and show's a level of sophistication.  Go ahead, impress people, throw some tooltips into your GUI.      </p>
<h4 id="size">Size</h4>
<p>Specifies the amount of room reserved for the Element.  For elements that are character based, such a Text, it is (# characters, # rows).  Sometimes it is a pixel measurement such as the Image element.  And sometimes a mix like on the Slider element (characters long by pixels wide).      </p>
<h4 id="colors">Colors</h4>
<p>A string representing color.  Anytime colors are involved, you can specify the tkinter color name such as 'lightblue' or an RGB hex value '#RRGGBB'.  For buttons, the color parameter is a tuple (text color, background color)    </p>
<h4 id="pad">Pad</h4>
<p>The amount of room around the element in pixels. The default value is (5,3) which means leave 5 pixels on each side of the x-axis and 3 pixels on each side of the y-axis.  You can change this on a global basis using a call to SetOptions, or on an element basis.    </p>
<p>If you want more pixels on one side than the other, then you can split the number into 2 number.  If you want 200 pixels on the left side, and 3 pixels on the right, the pad would be ((200,3), 3).  In this example, only the x-axis is split.    </p>
<h4 id="font">Font</h4>
<p>Specifies the font family, size, and style.  Font families on Windows include:  <br />
<em> Arial  <br />
</em> Courier  <br />
<em> Comic,  <br />
</em> Fixedsys  <br />
<em> Times  <br />
</em> Verdana  <br />
* Helvetica (the default I think)    </p>
<p>The fonts will vary from system to system, however, Tk 8.0 automatically maps Courier, Helvetica and Times to their corresponding native family names on all platforms.  Also, font families cannot cause a font specification to fail on Tk 8.0 and greater.  </p>
<p>If you wish to leave the font family set to the default, you can put anything not a font name as the family.  The PySimpleGUI Demo programs and documentation use the family 'Any' to demonstrate this fact..  You could use "default" if that's more clear to you.    </p>
<p>There are 2 formats that can be used to specify a font... a string, and a tuple  <br />
Tuple - (family, size, styles)  <br />
String - "Family Size Styles"    </p>
<p>To specify an underlined, Helvetica font with a size of 15 the values:  <br />
('Helvetica', 15, 'underline italics')  <br />
'Helvetica 15 underline italics'    </p>
<h4 id="key">Key</h4>
<p>If you are going to do anything beyond the basic stuff with your GUI, then you need to understand keys.  <br />
Keys are a way for you to "tag" an Element with a value that will be used to identify that element.  After you put a key in an element's definition, the values returned from Read will use that key to tell you the value.  For example, if you have an input field:  <br />
Input(key='mykey')  <br />
And your read looks like this:  <br />
event, values = Read()  <br />
Then to get the input value from the read it would be:  <br />
values['mykey']  <br />
You also use the same key if you want to call Update on an element.  Please see the section below on Updates to understand that usage.    </p>
<h4 id="visible">Visible</h4>
<p>Beginning in version 3.17 you can create Elements that are initially invisible that you can later make visible.</p>
<p>To create an invisible Element, place the element in the layout like you normally would and add the parameter <code>visible=False</code>.  </p>
<p>Later when you want to make that Element visible you simply call the Element's <code>Update</code> method and pass in the parameter <code>visible=True</code></p>
<p>This feature works best on Qt, but does work on the tkinter version as well.  The visible parameter can also be used with the Column and Frame "container" Elements.</p>
<h3 id="output-elements">Output Elements</h3>
<p>Building a window is simply making lists of Elements.  Each list is a row in the overall GUI dialog box.  The definition looks something like this:      </p>
<pre><code>layout = [ [row 1 element, row 1 element],      
           [row 2 element, row 2 element, row 2 element] ]
</code></pre>
<p>The code is a crude representation of the GUI, laid out in text.      </p>
<h2 id="shortcut-functions-multiple-function-names">Shortcut Functions / Multiple Function Names</h2>
<p>Many of the main method calls and Element names have shortcuts.  This enables you to code much quicker once you are used to using the SDK.  The Text Element, for example, has 3 different names <code>Text</code>, <code>Txt</code> or<code>T</code>.  InputText can also be written <code>Input</code> or <code>In</code> .  <code>FindElement</code> was recently renamed to <code>Element</code> because it's a commonly used function.</p>
<h2 id="text-element">Text Element</h2>
<pre><code>layout = [[sg.Text('This is what a Text Element looks like')]]
</code></pre>
<p><img alt="simple text" src="https://user-images.githubusercontent.com/13696193/44959877-e9d97b00-aec3-11e8-9d24-b4405ee4a148.jpg" />      </p>
<p>The most basic element is the Text element.  It simply displays text.  Many of the 'options' that can be set for a Text element are shared by other elements.      </p>
<pre><code class="python">   Text(text,
        size=(None, None), 
        auto_size_text=None,
        click_submits=False, 
        enable_events=False,
        relief=None,
        font=None, 
        text_color=None, 
        background_color=None, 
        justification=None, 
        pad=None, 
        key=None, 
        right_click_menu=None, 
        tooltip=None, 
        visible=True)
</code></pre>

<p>.      </p>
<pre><code>Text - The text that's displayed      
size - Element's size      
click_submits - if clicked will cause a read call to return the key value of the button      
enable_events - same as click_submits
relief - relief to use around the text      
auto_size_text - Bool. Change width to match size of text      
font - Font name and size to use      
text_color - text color      
background_color - background color      
justification - Justification for the text. String - 'left', 'right', 'center'      
pad - (x,y) amount of padding in pixels to use around element when packing      
key - used to identify element.  This value will return as button if click_submits True     
right_click_menu - menu definition to display if right clicked
tooltip - string representing tooltip
</code></pre>
<p>Some commonly used elements have 'shorthand' versions of the functions to make the code more compact.  The functions <code>T</code> and <code>Txt</code> are the same as calling <code>Text</code>.      </p>
<h3 id="fonts">Fonts</h3>
<pre><code>Already discussed in the common parameters section.  Either string or a tuple.
</code></pre>
<h3 id="color-in-pysimplegui-are-in-one-of-two-formats-color-name-or-rgb-value">Color in PySimpleGUI are in one of two formats - color name or RGB value.</h3>
<p>Individual colors are specified using either the color names as defined in tkinter or an RGB string of this format:      </p>
<pre><code>"#RRGGBB"        or          "darkblue"
</code></pre>
<h3 id="auto_size_text"><code>auto_size_text</code></h3>
<p>A <code>True</code> value for <code>auto_size_text</code>, when placed on Text Elements, indicates that the width of the Element should be shrunk do the width of the text.   The default setting is True.      </p>
<h3 id="chortcut-functions">Chortcut functions</h3>
<p>The shorthand functions for <code>Text</code> are <code>Txt</code> and <code>T</code>      </p>
<h3 id="events-enable_events">Events <code>enable_events</code></h3>
<p>If you set the parameter <code>enable_events</code> or <code>click_submits</code> then you will get an event if the user clicks on the Text.  </p>
<h3 id="text-methods">Text Methods</h3>
<h4 id="update">Update</h4>
<p>If you want to change the text, font, or colors after the element has been created, then use the <code>Update</code> method.</p>
<pre><code class="python"> Update(value = None, background_color=None, text_color=None, font=None, visible=None)    
</code></pre>

<p>value - new value to set text element to  <br />
background_color - new background color  <br />
text_color - text color to display  <br />
font - font to use to display 
visible - visibility   </p>
<h2 id="multiline-text-element">Multiline Text Element</h2>
<pre><code>layout = [[sg.Multiline('This is what a Multi-line Text Element looks like', size=(45,5))]]
</code></pre>
<p><img alt="multiline" src="https://user-images.githubusercontent.com/13696193/44959853-b139a180-aec3-11e8-972f-f52188510c88.jpg" />      </p>
<p>This Element doubles as both an input and output Element.      </p>
<pre><code class="python">Multiline(  default_text='',
            enter_submits=False,
            disabled=False,
            autoscroll=False,
            size=(None, None),
            auto_size_text=None,
            background_color=None,
            text_color=None,
            change_submits=False,
            enable_events=False,
            do_not_clear=False,
            key=None,
            focus=False,
            font=None,
            pad=None,
            tooltip=None
            right_click_menu=None,
            visible=True)
'''
</code></pre>

<pre><code>default_text - Text to display in the text box      
change_submits - Bool. If True, pressing Enter key submits window 
anable_events - Bool. same as change_submits
autoscroll - Bool.  Causes "cursor" to always be at the end of the text   
size - Element's size  
right_click_menu - menu definition to displat if right clicked    
auto_size_text - Bool. Change width to match size of text
</code></pre>
<h3 id="multiline-methods">Multiline Methods</h3>
<pre><code class="python">Update( value=None,
        disabled=None,
        append=False,
        font=None,
        text_color=None,
        background_color=None)

Update(self, value=None, disabled=None, append=False, font=None, text_color=None, background_color=None)value=None, disabled=None, append=False):    
</code></pre>

<p>value - string to set the text field to  <br />
disabled - set to True to disable the element  <br />
append - rather than replacing the current text with new text, add the new text onto the end    </p>
<h2 id="output-element">Output Element</h2>
<p>Output re-routes <code>Stdout</code> to a scrolled text box. </p>
<p>Whatever you print will show up in this window.  </p>
<p>Note that you will NOT see what you print until you call either window.Read or window.Refresh.  If you want to immediately see what was printed, call window.Refresh() immediately after your print statement.</p>
<pre><code>layout = [[sg.Output(size=(80,10)]]
</code></pre>
<p><img alt="output" src="https://user-images.githubusercontent.com/13696193/44959863-b72f8280-aec3-11e8-8caa-7bc743149953.jpg" />      </p>
<pre><code class="python">Output( size=(None, None),
        background_color=None,
        text_color=None,
        pad=None,
        font=None,
        tooltip=None,
        right_click_menu=None,
        key=None,
        visible=True)
</code></pre>

<p>size - Size of Output Element (width, height) in characters
You should be quite familiar with these parameters by now.  If not, read able another element or read about common parameters.</p>
<h2 id="input-elements">Input Elements</h2>
<p>These make up the majority of the window definition.  Optional variables at the Element level override the window level values (e.g. <code>size</code> is specified in the Element).  All input Elements create an entry in the list of return values.  A Text Input Element creates a string in the list of items returned.      </p>
<h2 id="text-input-element-shortcuts-input-in">Text Input Element    Shortcuts (Input, In)</h2>
<pre><code>layout = [[sg.InputText('Default text')]]
</code></pre>
<p><img alt="inputtext 2" src="https://user-images.githubusercontent.com/13696193/44959861-b5fe5580-aec3-11e8-8040-53ec241b5079.jpg" />      </p>
<pre><code class="python">      def InputText(default_text ='',    
                    size=(None, None),    
                    disabled=False,     
                    auto_size_text=None,    
                    password_char='',      
                    justification=None,    
                    background_color=None,    
                    text_color=None,    
                    font=None,    
                    tooltip=None,    
                    change_submits=False
                    do_not_clear=False,    
                    key=None,    
                    focus=False,  
                    right_click_menu=None,  
                    pad=None,
                    vitible=True):      
</code></pre>

<p>.      </p>
<pre><code> default_text - Text initially shown in the input box      
 size - (width, height) of element in characters      
 auto_size_text- Bool.  True is element should be sized to fit text      
 disabled - Bool If True the input is disabled    
 password_char - Character that will be used to replace each entered character. Setting to a value indicates this field is a password entry field      
 background_color - color to use for the input field background      
 text_color - color to use for the typed text      
 font - font used for the element
 tooltip - what is shown when hovered over element (doesn't appear to work)
 change_submits - if True, will cause a Window.Read to return if a button fills in the value
 do_not_clear - Bool. Normally windows clear when read, turn off clearing with this flag.      
 key = Dictionary key to use for return values      
 focus = Bool. True if this field should capture the focus (moves cursor to this field)      
 pad - amount of room in pixels to leave around the element
</code></pre>
<p>There are two methods that can be called:      </p>
<pre><code> Input.Update(new_Value) - sets the input to new_value      
 Input.Get() - returns the current value of the field.
</code></pre>
<p>Shorthand functions that are equivalent to <code>InputText</code> are <code>Input</code> and <code>In</code>      </p>
<h4 id="do_not_clear-parameter"><code>do_not_clear</code> Parameter</h4>
<p><strong>Important</strong> - This trips a lot of people up.  If you do not set the <code>do_not_clear</code> parameter then the input field will clear when an event takes place.   The behavior is a "forms" style window development.  The assumption is that you want the field to clear.  If you are writing a chat program then you're thankful.  The rest of you, I'm sorry.</p>
<h3 id="textinput-methods">TextInput Methods</h3>
<pre><code class="python">Update(value=None, disabled=None):    
Get()    
</code></pre>

<p>Update - Change the Element  <br />
value - new value to display in field  <br />
disabled - if True will disable the element    </p>
<p>Get - Returns the current value for the element (you can get also from a call to Read)    </p>
<h2 id="combo-element">Combo Element</h2>
<p>Also known as a drop-down list.  Only required parameter is the list of choices.  The return value is a string matching what's visible on the GUI.      </p>
<pre><code>layout = [[sg.InputCombo(['choice 1', 'choice 2'])]]
</code></pre>
<p><img alt="combobox" src="https://user-images.githubusercontent.com/13696193/44959860-b565bf00-aec3-11e8-82fe-dbe41252458b.jpg" />      </p>
<pre><code>InputCombo(values,    ,      
           default_value=None      
           size=(None, None)      
           auto_size_text=None      
           background_color=None      
           text_color=None      
           change_submits=False 
           enable_events=False
           readonly=True     
           disabled=False      
           key=None      
           pad=None      
           tooltip=None   
           visible=True)
</code></pre>
<p>.      </p>
<pre><code> values - Choices to be displayed. List of strings      
 default_value - which value should be initially chosen      
 size - (width, height) of element in characters      
 auto_size_text - Bool. True if size should fit the text length      
 background_color - color to use for the input field background      
 text_color - color to use for the typed text      
 change_submits - Bool. If set causes Read to immediately return if the selected value changes      
 disabled - Bool. If set will disable changes   
 readonly - Bool. If set user cannot change the values to choose from   
 key - Dictionary key to use for return values      
 pad - (x,y) Amount of padding to put around element in pixels      
 tooltip -  Text string. If set, hovering over field will popup the text
</code></pre>
<p>Shortcut functions - Combo, DropDown, Drop    </p>
<h3 id="combo-methods">Combo Methods</h3>
<pre><code class="python">Update(value=None, values=None, set_to_index=None, disabled=None, readonly=None)    
</code></pre>

<p>value - change which value is current selected  <br />
values - change list of choices  <br />
set_to_index - change selection to a particular choice  <br />
disable - if True will disable element  <br />
readonly - if True will make element readonly</p>
<h2 id="listbox-element">Listbox Element</h2>
<p>The standard listbox like you'll find in most GUIs.  Note that the return values from this element will be a <strong><em>list of results, not a single result</em></strong>. This is because the user can select more than 1 item from the list (if you set the right mode).      </p>
<pre><code>layout = [[sg.Listbox(values=['Listbox 1', 'Listbox 2', 'Listbox 3'], size=(30, 6))]]
</code></pre>
<p><img alt="listbox 2" src="https://user-images.githubusercontent.com/13696193/44959859-b4cd2880-aec3-11e8-881c-1e369d5c6337.jpg" />      </p>
<pre><code>     Listbox(values      
             default_values=None      
             select_mode=None      
             change_submits=False      
             bind_return_key=False      
             size=(None, None)      
             disabled = False,    
             auto_size_text=None      
             font=None      
             background_color=None      
             text_color=None      
             key=None      
             pad=None      
             right_click_menu=None                
             tooltip=None,
             visible=True):
</code></pre>
<p>.      </p>
<pre><code>values - Choices to be displayed. List of strings      
select_mode - Defines how to list is to operate.      
     Choices include constants or strings:      
     Constants version:      
   LISTBOX_SELECT_MODE_BROWSE      
   LISTBOX_SELECT_MODE_EXTENDED      
   LISTBOX_SELECT_MODE_MULTIPLE      
   LISTBOX_SELECT_MODE_SINGLE - the default      
   Strings version:      
   'browse'      
   'extended'      
   'multiple'      
   'single'      
change_submits - if True, the window read will return with a button value of ''      
bind_return_key - if the focus is on the listbox and the user presses return key, or if the user double clicks an item, then the read will return      
size - (width, height) of element in characters      
disapled - Bool. If True element is disabled    
auto_size_text - Bool. True if size should fit the text length      
background_color - color to use for the input field background      
font - font to use for items in list      
text_color - color to use for the typed text      
key - Dictionary key to use for return values and to find element      
pad - amount of padding to use when packing      
tooltip - tooltip text
</code></pre>
<p>The <code>select_mode</code> option can be a string or a constant value defined as a variable.  Generally speaking strings are used for these kinds of options.      </p>
<p>ListBoxes can cause a window to return from a Read call.  If the flag change_submits is set, then when a user makes a selection, the Read immediately returns.    <br />
Another way ListBoxes can cause Reads to return is if the flag bind_return_key is set.  If True, then if the user presses the return key while an entry is selected, then the Read returns.  Also, if this flag is set, if the user double-clicks an entry it will return from the Read.      </p>
<h3 id="listbox-methods">Listbox Methods</h3>
<pre><code class="python">Update(values=None, disabled=None)    
SetValue(values)    
GetListValues()    

</code></pre>

<p>Update - Change element  <br />
values - new list of choices  <br />
disabled - if True disables the element    </p>
<p>SetValue - Sets selection to one or more values    </p>
<p>GetListValues - Return the list of values to choose from    </p>
<h2 id="slider-element">Slider Element</h2>
<p>Sliders have a couple of slider-specific settings as well as appearance settings.  Examples include the <code>orientation</code> and <code>range</code> settings.      </p>
<pre><code>layout = [[sg.Slider(range=(1,500), default_value=222, size=(20,15), orientation='horizontal', font=('Helvetica', 12))]]
</code></pre>
<p><img alt="slider" src="https://user-images.githubusercontent.com/13696193/44959858-b4349200-aec3-11e8-9e25-c0fcf025d19e.jpg" />      </p>
<pre><code>   Slider(range=(None,None),    
        default_value=None,    
        resolution=None,     
        orientation=None,    
        border_width=None,     
        relief=None,    
        change_submits=False,    
        disabled=False,     
        size=(None, None),    
        font=None,     
        background_color=None,     
        text_color=None,     
        key=None,     
        pad=None,    
        tooltip=None,
        visible=True)
</code></pre>
<p>.      </p>
<pre><code>  range - (min, max) slider's range      
  default_value - default setting (within range)      
  resolution - how much each 'tick' should represent. Default = 1    
  orientation - 'horizontal' or 'vertical' ('h' or 'v' work)      
  border_width - how deep the widget looks      
  relief - relief style. Values are same as progress meter relief values.  Can be a constant or a string:      
     RELIEF_RAISED= 'raised'      
     RELIEF_SUNKEN= 'sunken'      
     RELIEF_FLAT= 'flat'      
     RELIEF_RIDGE= 'ridge'      
     RELIEF_GROOVE= 'groove'      
     RELIEF_SOLID = 'solid'      
   size - (width, height) of element in characters      
   disabled - Bool If True slider is disabled    
   auto_size_text - Bool. True if size should fit the text      
   background_color - color to use for the input field background      
   text_color - color to use for the typed text      
   change_submits - causes window read to immediately return if the checkbox value changes      
   key- Dictionary key to use for return values      
   tooltip - Tooltip to display when hovered over wlement
</code></pre>
<h3 id="qt-sliders">Qt Sliders</h3>
<p>There is an important difference between Qt and tkinter sliders.  On Qt, the slider values must be integer, not float.  If you want your slider to go from 0.1 to 1.0, then make your slider go from 1 to 10 and divide by 10.  It's an easy math thing to do and not a big deal.  Just deal with it.... you're writing software after all.  Presumably you know how to do these things.  ;-)</p>
<h3 id="slider-methods">Slider Methods</h3>
<pre><code class="python">Update(self, value=None, range=(None, None), disabled=None, visible=None):    
</code></pre>

<p>value - set current selection to value  <br />
range - change range of valid values  <br />
disabled - if True disables element    </p>
<h2 id="radio-button-element">Radio Button Element</h2>
<p>Creates one radio button that is assigned to a group of radio buttons.  Only 1 of the buttons in the group can be selected at any one time.      </p>
<pre><code>layout =  [[sg.Radio('My first Radio!', "RADIO1", default=True), sg.Radio('My second radio!', "RADIO1")]]
</code></pre>
<p><img alt="radio" src="https://user-images.githubusercontent.com/13696193/44959857-b4349200-aec3-11e8-8e2d-e6a49ffbd0b6.jpg" />      </p>
<pre><code> Radio(text,      
       group_id,      
       default=False,      
       size=(None, None),      
       disabled = False,    
       auto_size_text=None,      
       font=None,      
       background_color = None,      
       text_color = None,      
       key = None,    
       pad = None,    
       tooltip = None,
       visible=True)
</code></pre>
<p>.      </p>
<pre><code> text - Text to display next to button      
 group_id - Groups together multiple Radio Buttons. Can be any value      
 default - Bool.  Initial state      
 size - (width, height) size of element in characters      
 auto_size_text - Bool.  True if should size width to fit text      
 font - Font type and size for text display      
 background_color - color to use for the background      
 text_color - color to use for the text      
 key - Dictionary key to use for return values      
 pad - padding around element    
 tooltip - tooltip to show when mouse hovered over element
</code></pre>
<h3 id="radio-button-methods">Radio Button Methods</h3>
<pre><code class="python">Update(value=None, disabled=None, visible=None)    
</code></pre>

<p>value - bool - if True change to selected  <br />
disabled - if True disables the element    </p>
<h2 id="checkbox-element">Checkbox Element</h2>
<p>Checkbox elements are like Radio Button elements.  They return a bool indicating whether or not they are checked.      </p>
<pre><code>layout =  [[sg.Checkbox('My first Checkbox!', default=True), sg.Checkbox('My second Checkbox!')]]
</code></pre>
<p><img alt="checkbox" src="https://user-images.githubusercontent.com/13696193/44959906-6f5d2b00-aec4-11e8-9c8a-962c787f0286.jpg" />      </p>
<pre><code>Checkbox(text,      
         default=False,      
         size=(None, None),      
         auto_size_text=None,      
         font=None,      
         background_color = None,      
         text_color = None,      
         change_submits = False      
         disabled = False,    
         key = None,    
         pad = None,    
         tooltip = None,
         visible=True):
</code></pre>
<p>.      </p>
<pre><code> text - Text to display next to checkbox      
 default- Bool + None.  Initial state. True = Checked, False = unchecked, None = Not available (grayed out)      
 size - (width, height) size of element in characters      
 auto_size_text- Bool.  True if should size width to fit text      
 disabled - Bool. If True element is disabled    
 font- Font type and size for text display      
 background_color - color to use for the background      
 text_color - color to use for the typed text      
 change_submits - causes window read to immediately return if the checkbox value changes      
 key = Dictionary key to use for return values      
 pad - Padding around element in window    
 tooltip - text to show when mouse is hovered over element
</code></pre>
<p>Shortcut functions -   CBox, CB, Check    </p>
<h3 id="checkbox-methods">Checkbox Methods</h3>
<pre><code class="python">Update(value=None, disabled=None, visible=None)    
Get()    
</code></pre>

<p>Update - changes the element  <br />
value - Bool if True checks the checkbox  <br />
disabled - if True disables the element    </p>
<p>Get - returns current state    </p>
<h2 id="spin-element">Spin Element</h2>
<p>An up/down spinner control.  The valid values are passed in as a list.      </p>
<pre><code>layout =  [[sg.Spin([i for i in range(1,11)], initial_value=1), sg.Text('Volume level')]]
</code></pre>
<p><img alt="spinner" src="https://user-images.githubusercontent.com/13696193/44959855-b1d23800-aec3-11e8-9f51-afb2109879da.jpg" />      </p>
<pre><code>Spin(values,      
     intiial_value=None,     
     disabled = False,     
     size=(None, None),      
     change_submits = False,    
     auto_size_text=None,      
     font=None,      
     background_color = None,      
     text_color = None,      
     key = None.    
     pad = None,    
     tooltip = None,
     visible=True):
</code></pre>
<p>Parameter definitions    </p>
<pre><code> values - List of valid values      
 initial_value - String with initial value      
 size - (width, height) size of element in characters      
 auto_size_text - Bool.  True if should size width to fit text      
 font - Font type and size for text display      
 disabled - Bool. If True element is disabled    
 background_color - color to use for the background      
 text_color - color to use for the typed text      
 change_submits - causes window read to immediately return if the spinner value changes      
 key = Dictionary key to use for return values      
 pad - padding around element in the window    
 tooltip - text to show when mouse hovered over element
</code></pre>
<h3 id="qt-differences-values-is-a-range">Qt Differences - <code>values</code> is a range!</h3>
<p>Note that Qt does not allow arbitrary spinner values.  With PySimpleGUI-tkinter you can have any values in your list.  In Qt they must be integers.  Yea, it kinda sucks.  I'm working on it.</p>
<p>On Qt values is a tuple representing a range.  On plain PySimpleGUI this value is a list of items.  Make sure on the plain version you specify items as a list using [] and not a generator using ().</p>
<h3 id="spin-methods">Spin Methods</h3>
<pre><code class="python">Update(value=None, values=None, disabled=None, visible=None)    
</code></pre>

<p>value - set the current value  <br />
values - set available choices  <br />
disabled - if True disables the element    </p>
<h2 id="image-element">Image Element</h2>
<p>Images can be placed in your window provide they are in PNG, GIF, PPM/PGM format.  JPGs cannot be shown because tkinter does not naively support JPGs.  You can use the Python Imaging Library (PIL) package  to convert your image to PNG prior to calling PySimpleGUI if your images are in JPG format.    </p>
<pre><code class="python">  Image(filename=None,
        data=None,
        data_base64=None,
        background_color=None,
        size=(None,None),
        pad=None,
        key=None,
        tooltip=None,
        click_submits=False,
        enable_events=False,
        visible=True,
        right_click_menu=None,      
        size_px=(None,None)  
        visible=True)  
</code></pre>

<p>Parameter definitions    </p>
<pre><code>filename - file name if the image is in a file    
data - if image is in RAM (PIL format?)  
data_base64 - image in base64 format  
background_color - Color of background    
size - Size (Width, Height) of image in pixels    
pad - Padding around Element in the window    
key - Key used to find the element    
tooltip - text to show when mouse if hovered over image    
click_submits, enable_events - if True returns event when image is clicked
visible - if False will create image as hidden
size_px - size of image in pixels
</code></pre>
<h3 id="update-method"><code>Update</code> Method</h3>
<p>Like other Elements, the Image Element has an <code>Update</code> method.  Call Update if you want to change the image.    </p>
<pre><code>def Update(self, filename=None, data=None, visible=None):
</code></pre>
<p>Choose <strong>either</strong> a filename or in-ram data image to use to replace current image    </p>
<h3 id="updateanimation-method-for-animated-gifs"><code>UpdateAnimation</code> Method  for Animated GIFs</h3>
<p><img alt="loading animation" src="https://user-images.githubusercontent.com/13696193/51280871-d2041e80-19ae-11e9-8757-802eb95352ed.gif" /></p>
<p>Starting in version 3.23 you can specify an animated GIF as an image and can animate the GIF by calling <code>UpdateAnimation</code>.  Exciting stuff!</p>
<pre><code class="python">UpdateAnimation(source,
                time_between_frames=0)
</code></pre>

<p><code>source</code> can be a filename <strong><em>or</em></strong> a base64 bytes variable (unlike other calls that split out the filename parameter and base64 parameter into 2 parameters.</p>
<p><code>time_between_frames</code> is an optional parameter.  It will keep track of the amount of time between frame changes for you to give you a smooth animation.  With this parameter you can call the function as often as you want and it will advance to the next frame only after the correct amount of time has lapsed. </p>
<p>You can call the method without setting the <code>time_between_frames</code> value and it will show a frame and immediately move on to the next frame.  This enables you to do the inter-frame timing.</p>
<h2 id="button-element">Button Element</h2>
<p><strong>MAC USERS</strong> - Macs suck when it comes to tkinter and button colors.  It sucks so badly with colors that the <code>LookAndFeel</code> call is disabled.  You cannot change button colors for Macs.  You're stuck with the system default color if you are using the tkinter version of PySimpleGUI.  The Qt version does not have this issue.</p>
<p>Buttons are the most important element of all!  They cause the majority of the action to happen.  After all, it's a button press that will get you out of a window, whether it be Submit or Cancel, one way or another a button is involved in all windows.  The only exception is to this is when the user closes the window using the "X" in the upper corner which means no button was involved.      </p>
<p>The Types of buttons include:    <br />
<em> Folder Browse    <br />
</em> File Browse    <br />
<em> Files Browse    <br />
</em> File SaveAs    <br />
<em> File Save    <br />
</em> Close window  (normal button)    <br />
<em> Read window    <br />
</em> Realtime    <br />
<em> Calendar Chooser    <br />
</em> Color Chooser      </p>
<p>Close window - Normal buttons like Submit, Cancel, Yes, No, do NOT close the window... they used to.  Now to close a window you need to use a CloseButton / CButton.</p>
<p>Folder Browse - When clicked a folder browse dialog box is opened.  The results of the Folder Browse dialog box are written into one of the input fields of the window.      </p>
<p>File Browse - Same as the Folder Browse except rather than choosing a folder, a single file is chosen.      </p>
<p>Calendar Chooser - Opens a graphical calendar to select a date.      </p>
<p>Color Chooser - Opens a color chooser dialog      </p>
<p>Read window - This is a window button that will read a snapshot of all of the input fields, but does not close the window after it's clicked.      </p>
<p>Realtime - This is another async window button.  Normal button clicks occur after a button's click is released.  Realtime buttons report a click the entire time the button is held down.      </p>
<p>Most programs will use a combination of shortcut button calls (Submit, Cancel, etc), normal Buttons which leave the windows open and CloseButtons that close the window when clicked.</p>
<p>Sometimes there are multiple names for the same function.  This is simply to make the job of the programmer quicker and easier.  Or they are old names that are no longer used but kept around so that existing programs don't break.   </p>
<p>The 4 primary windows of PySimpleGUI buttons and their names are:      </p>
<ol>
<li><code>Button</code>= <code>ReadButton</code> = <code>RButton</code> = <code>ReadFormButton</code> (old style... use Button instead)      </li>
<li><code>CloseButton</code> = <code>CButton</code></li>
<li><code>RealtimeButton</code>      </li>
<li><code>DummyButton</code></li>
</ol>
<p>You will find the long-form names in the older programs. ReadButton for example. </p>
<p>In Oct 2018, the definition of Button changed.  Previously Button would CLOSE the window when clicked.  It has been changed so the Button calls will leave the window open in exactly the same way as a ReadButton.  They are the same calls now.   To enables windows to be closed using buttons, a new button was added... <code>CloseButton</code> or <code>CButton</code>.</p>
<p>The most basic Button element call to use is <code>Button</code>      </p>
<pre><code>Button(button_text=''      
       button_type=BUTTON_TYPE_CLOSES_WIN      
       target=(None, None)      
       tooltip=None      
       file_types=(("ALL Files", "*.*"),)      
       initial_folder=None      
       disabled = False    
       image_filename=None      
       image_data=None    
       image_size=(None, None)      
       image_subsample=None      
       border_width=None      
       size=(None, None)      
       auto_size_button=None      
       button_color=None      
       default_value = None      
       font=None      
       bind_return_key=False      
       focus=False      
       pad=None      
       key=None,
       visible=True):
</code></pre>
<p>Parameters      </p>
<pre><code>button_text - Text to be displayed on the button      
button_type - You  should NOT be setting this directly      
target - key or (row,col) target for the button      
tooltip - tooltip text for the button      
file_types - the filetypes that will be used to match files      
initial_folder - starting path for folders and files      
disabled = Bool If True button is disabled    
image_filename - image filename if there is a button image      
image_data - in-RAM image to be displayed on button    
image_size - size of button image in pixels      
image_subsample - amount to reduce the size of the image      
border_width - width of border around button in pixels      
size - size in characters      
auto_size_button - True if button size is determined by button text      
button_color - (text color, backound color)      
default_value - initial value for buttons that hold information      
font - font to use for button text      
bind_return_key - If True the return key will cause this button to fire      
focus - if focus should be set to this button      
pad - (x,y) padding in pixels for packing the button      
key - key used for finding the element
</code></pre>
<h3 id="shortcut-pre-defined-buttons">Shortcut, Pre-defined Buttons</h3>
<p>These Pre-made buttons are some of the most important elements of all because they are used so much.  They all basically do the same thing, set the button text to match the function name and set the parameters to commonly used values. If you find yourself needing to create a custom button often because it's not on this list, please post a request on GitHub. . They include:      </p>
<pre><code>OK      
Ok      
Submit      
Cancel      
Yes      
No      
Exit      
Quit      
Help      
Save      
SaveAs      
FileBrowse      
FilesBrowse      
FileSaveAs      
FolderBrowse
</code></pre>
<p><strong>IMPORT NOTE ABOUT SHORTCUT BUTTONS</strong>
Prior to release 3.11.0, these buttons closed the window.  Starting with 3.11 they will not close the window.  They act like RButtons (return the button text and do not close the window)</p>
<p>If you are having trouble with these buttons closing your window, please check your installed version of PySimpleGUI by typing <code>pip list</code> at a command prompt.  Prior to 3.11 these buttons close your window.  </p>
<p>Using older versions, if you want a Submit() button that does not close the window, then you would instead use RButton('Submit').   Using the new version, if you want a Submit button that closes the window like the sold Submit() call did, you would write that as <code>CloseButton('Submit')</code> or <code>CButton('Submit')</code></p>
<pre><code>layout =  [[sg.OK(), sg.Cancel()]]
</code></pre>
<p><img alt="ok cancel 3" src="https://user-images.githubusercontent.com/13696193/44959927-aa5f5e80-aec4-11e8-86e1-5dc0b3a2b803.jpg" />      </p>
<h3 id="button-targets">Button targets</h3>
<p>The <code>FileBrowse</code>, <code>FolderBrowse</code>, <code>FileSaveAs</code> , <code>FilesSaveAs</code>, <code>CalendarButton</code>, <code>ColorChooserButton</code> buttons all fill-in values into another element located on the window.  The target can be a Text Element or an InputText Element.  The location of the element is specified by the <code>target</code> variable in the function call.      </p>
<p>The Target comes in two forms.    <br />
1. Key    <br />
2. (row, column)      </p>
<p>Targets that are specified using a key will find its target element by using the target's key value.  This is the "preferred" method.      </p>
<p>If the Target is specified using (row, column) then it utilizes a grid system.  The rows in your GUI are numbered starting with 0. The target can be specified as a hard coded grid item or it can be relative to the button.      </p>
<p>The (row, col) targeting can only target elements that are in the same "container".  Containers are the Window, Column and Frame Elements.  A File Browse button located inside of a Column is unable to target elements outside of that Column.      </p>
<p>The default value for <code>target</code> is <code>(ThisRow, -1)</code>.   <code>ThisRow</code> is a special value that tells the GUI to use the same row as the button.  The Y-value of -1 means the field one value to the left of the button.  For a File or Folder Browse button, the field that it fills are generally to the left of the button is most cases.    (ThisRow, -1) means the Element to the left of the button, on the same row.      </p>
<p>If a value of <code>(None, None)</code> is chosen for the target, then the button itself will hold the information.  Later the button can be queried for the  value by using the button's key.      </p>
<p>Let's examine this window as an example:      </p>
<p><img alt="file browse" src="https://user-images.githubusercontent.com/13696193/44959944-d1b62b80-aec4-11e8-8a68-9d79d37b2c81.jpg" />      </p>
<p>The <code>InputText</code> element is located at (1,0)... row 1, column 0.  The <code>Browse</code> button is located at position (2,0).  The Target for the button could be any of these values:      </p>
<pre><code>Target = (1,0)      
Target = (-1,0)
</code></pre>
<p>The code for the entire window could be:      </p>
<pre><code>layout = [[sg.T('Source Folder')],      
          [sg.In()],      
          [sg.FolderBrowse(target=(-1, 0)), sg.OK()]]
</code></pre>
<p>or if using keys, then the code would be:      </p>
<pre><code>layout = [[sg.T('Source Folder')],      
          [sg.In(key='input')],      
          [sg.FolderBrowse(target='input'), sg.OK()]]
</code></pre>
<p>See how much easier the key method is?      </p>
<p><strong>Save &amp; Open Buttons</strong>      </p>
<p>There are 4 different types of File/Folder open dialog box available.  If you are looking for a file to open, the <code>FileBrowse</code> is what you want. If you want to save a file, <code>SaveAs</code> is the button. If you want to get a folder name, then <code>FolderBrowse</code> is the button to use. To open several files at once, use the <code>FilesBrowse</code> button.  It will create a list of files that are separated by ';'      </p>
<p><img alt="open" src="https://user-images.githubusercontent.com/13696193/45243804-2b529780-b2c3-11e8-90dc-6c9061db2a1e.jpg" />      </p>
<p><img alt="folder" src="https://user-images.githubusercontent.com/13696193/45243805-2b529780-b2c3-11e8-95ee-fec3c0b11319.jpg" />      </p>
<p><img alt="saveas" src="https://user-images.githubusercontent.com/13696193/45243807-2beb2e00-b2c3-11e8-8549-ba71cdc05951.jpg" />      </p>
<p><strong>Calendar Buttons</strong>      </p>
<p>These buttons pop up a calendar chooser window.  The chosen date is returned as a string.      </p>
<p><img alt="calendar" src="https://user-images.githubusercontent.com/13696193/45243374-99965a80-b2c1-11e8-8311-49777835ca40.jpg" />      </p>
<p><strong>Color Chooser Buttons</strong>      </p>
<p>These buttons pop up a standard color chooser window.  The result is returned as a tuple.  One of the returned values is an RGB hex representation.      </p>
<p><img alt="color" src="https://user-images.githubusercontent.com/13696193/45243375-99965a80-b2c1-11e8-9779-b71bed85fab6.jpg" />      </p>
<p><strong>Custom Buttons</strong>    <br />
Not all buttons are created equal.  A button that closes a window is different that a button that returns from the window without closing it.  If you want to define your own button, you will generally do this with the Button Element <code>Button</code>, which closes the window when clicked.      </p>
<p>layout =  [[sg.Button('My Button')]]      </p>
<p><img alt="button" src="https://user-images.githubusercontent.com/13696193/44959862-b696ec00-aec3-11e8-9e88-4b9af0338a03.jpg" />      </p>
<p>All buttons can have their text changed by changing the <code>button_text</code> variable in the button call.  It is this text that is returned when a window is read.  This text will be what tells you which button is called so make it unique.  Most of the convenience buttons (Submit, Cancel, Yes, etc) are all Buttons. Some that are not are <code>FileBrowse</code> ,  <code>FolderBrowse</code>, <code>FileSaveAs</code>.  They clearly do not close the window. Instead they bring up a file or folder browser dialog box.      </p>
<p><strong>Button Images</strong>    <br />
Now this is an exciting feature not found in many simplified packages.... images on buttons!  You can make a pretty spiffy user interface with the help of a few button images.      </p>
<p>Your button images need to be in PNG or GIF format.  When you make a button with an image, set the button background to the same color as the background.  There's a button color TRANSPARENT_BUTTON that you can set your button color to in order for it to blend into the background.  Note that this value is currently the same as the color as the default system background on Windows.  If you want to set the button background color to the current system default, use the value COLOR_SYSTEM_DEFAULT as the background color.</p>
<p>This example comes from the <code>Demo Media Player.py</code> example program.  Because it's a non-blocking button, it's defined as <code>RButton</code>.  You also put images on blocking buttons by using <code>Button</code>.      </p>
<pre><code>sg.RButton('Restart Song', button_color=sg.TRANSPARENT_BUTTON,      
                   image_filename=image_restart, image_size=(50, 50), image_subsample=2, border_width=0)
</code></pre>
<p>Three parameters are used for button images.      </p>
<pre><code>image_filename - Filename. Can be a relative path      
image_size - Size of image file in pixels      
image_subsample - Amount to divide the size by.  2 means your image will be 1/2 the size.  3 means 1/3
</code></pre>
<p>Here's an example window made with button images.      </p>
<p><img alt="media file player" src="https://user-images.githubusercontent.com/13696193/43161977-9ee7cace-8f57-11e8-8ff8-3ea24b69dab9.jpg" />      </p>
<p>You'll find the source code in the file Demo Media Player.  Here is what the button calls look like to create media player window        <br />
<code>python
    sg.RButton('Pause', button_color=sg.TRANSPARENT_BUTTON,      
                      image_filename=image_pause, 
                      image_size=(50, 50),
                      image_subsample=2, 
                      border_width=0)</code>
This is one you'll have to experiment with at this point.  Not up for an exhaustive explanation.      </p>
<p><strong>Realtime Buttons</strong>      </p>
<p>Normally buttons are considered "clicked" when the mouse button is let UP after a downward click on the button.  What about times when you need to read the raw up/down button values.  A classic example for this is a robotic remote control.  Building a remote control using a GUI is easy enough.  One button for each of the directions is a start.  Perhaps something like this:      </p>
<p><img alt="robot remote" src="https://user-images.githubusercontent.com/13696193/44959958-ff9b7000-aec4-11e8-99ea-7450926409be.jpg" />      </p>
<p>This window has 2 button types.  There's the normal "Read Button" (Quit) and 4 "Realtime Buttons".      </p>
<p>Here is the code to make, show and get results from this window:      </p>
<pre><code class="python">import PySimpleGUI as sg  

gui_rows = [[sg.Text('Robotics Remote Control')],  
            [sg.T(' '  * 10), sg.RealtimeButton('Forward')],  
            [sg.RealtimeButton('Left'), sg.T(' '  * 15), sg.RealtimeButton('Right')],  
            [sg.T(' '  * 10), sg.RealtimeButton('Reverse')],  
            [sg.T('')],  
            [sg.Quit(button_color=('black', 'orange'))]  
            ]  

window = sg.Window('Robotics Remote Control', auto_size_text=True).Layout(gui_rows)  

#  
# Some place later in your code...  
# You need to perform a Read or Refresh call on your window every now and then or  
# else it will apprear as if the program has locked up.  
#  
# your program's main loop  
while (True):  
    # This is the code that reads and updates your window  
    event, values = window.Read(timeout=0)  
    if event is not None:  
        print(event)  
    if event == 'Quit'  or values is None:  
        break       

window.Close()  # Don't forget to close your window!
</code></pre>

<p>This loop will read button values and print them.  When one of the Realtime buttons is clicked, the call to <code>window.Read</code> will  return a button name matching the name on the button that was depressed or the key if there was a key assigned to the button.  It will continue to return values as long as the button remains depressed.  Once released, the Read will return timeout events until a button is again clicked.      </p>
<p><strong>File Types</strong>    <br />
The <code>FileBrowse</code> &amp; <code>SaveAs</code> buttons have an additional setting named <code>file_types</code>.  This variable is used to filter the files shown in the file dialog box.  The default value for this setting is      </p>
<pre><code>FileTypes=(("ALL Files", "*.*"),)
</code></pre>
<p>This code produces a window where the Browse button only shows files of type .TXT      </p>
<pre><code>layout =  [[sg.In() ,sg.FileBrowse(file_types=(("Text Files", "*.txt"),))]]
</code></pre>
<p>NOTE - Mac users will not be able to use the file_types parameter.  tkinter has a bug on Macs that will crash the program is a file_type is attempted so that feature had to be removed.  Sorry about that!</p>
<p><strong><em>The ENTER key</em></strong>    <br />
       The ENTER key is an important part of data entry for windows.  There's a long  tradition of the enter key being used to quickly submit windows.  PySimpleGUI implements this by tying the ENTER key to the first button that closes or reads a window.      </p>
<p>The Enter Key can be "bound" to a particular button so that when the key is pressed, it causes the window to return as if the button was clicked.  This is done using the <code>bind_return_key</code> parameter in the button calls.    <br />
If there are more than 1 button on a window, the FIRST button that is of type Close window or Read window is used.  First is determined by scanning the window, top to bottom and left to right.      </p>
<h3 id="button-methods">Button Methods</h3>
<pre><code class="python">Update(text=None, button_color=(None, None), disabled=None, image_data=None, image_filename=None, visible=None)

GetText()    
</code></pre>

<p>Update - Change the button element    </p>
<pre><code>    text - sets button text    
    button color - (text, background)    
    disabled - if True disables the button    
    image_data - sets button image to in-ram image    
    image_filename - sets button image using a file
</code></pre>
<p>GetText - Returns the current text shown on a button</p>
<h2 id="buttonmenu-element">ButtonMenu Element</h2>
<p>The ButtonMenu element produces a unique kind of effect.  It's a button, that when clicked, shows you a menu.   It's like clicking one of the top-level menu items on a MenuBar.  As a result, the menu definition take the format of a single  menu entry from  a normal menu definition.  A normal menu definition is  a list of lists.  This definition is one of those lists.</p>
<p>Here is a sample definition:</p>
<pre><code class="python"> ['Menu', ['&amp;Pause Graph', 'Menu item::optional_key']]
</code></pre>

<p>The very first string normally specifies what is shown on the menu bar.  In this case, the value is <strong>not used</strong>.  You set the text for the button using a different parameter, the <code>button_text</code> parm.</p>
<pre><code class="python">ButtonMenu( button_text,
            menu_def, 
            tooltip=None,
            disabled=False, 
            image_filename=None, 
            image_data=None, 
            image_size=(None, None), 
            image_subsample=None,
            border_width=None,
            size=(None, None), 
            auto_size_button=None, 
            button_color=None, 
            font=None, 
            pad=None, 
            key=None, 
            visible=True, 
            size_px=(None,None)):
</code></pre>

<p>One use of this element is to make a "fake menu bar" that has a colored background.  Normal menu bars cannot have their background color changed.  Not so with ButtonMenus.</p>
<p>This is the effect:</p>
<p><img alt="buttonmenu" src="https://user-images.githubusercontent.com/13696193/50387000-bc0d8180-06c0-11e9-8d17-3b22ed665e78.gif" /></p>
<p>Return values for ButtonMenus are sent via the return values dictionary.  If a selection is made, then an event is generated that will equal the ButtonMenu's key value.  Use that key value to look up the value selected by the user.  This is the same mechanism as the Menu Bar Element, but differs from the pop-up (right click) menu.</p>
<h2 id="vertical-separator-element">Vertical Separator Element</h2>
<p>This element has limited usefulness and is being included more for completeness than anything else.  It will draw a line between elements.</p>
<pre><code class="python">VerticalSeparator(pad=None)
</code></pre>

<p><img alt="snag-0129" src="https://user-images.githubusercontent.com/13696193/47376041-a92a0100-d6bf-11e8-8f5b-0c0df56cf0f3.jpg" /></p>
<p>It works best when placed between columns or elements that span multiple rows.  If on a "normal" row with elements that are only 1 row high, then it will only span that one row.</p>
<h2 id="progressbar-element">ProgressBar  Element</h2>
<p>The <code>ProgressBar</code> element is used to build custom Progress Bar windows.  It is HIGHLY recommended that you use OneLineProgressMeter that provides a complete progress meter solution for you.  Progress Meters are not easy to work with because the windows have to be non-blocking and they are tricky to debug.      </p>
<p>The <strong>easiest</strong> way to get progress meters into your code is to use the <code>OneLineProgressMeter</code> API.  This consists of a pair of functions, <code>OneLineProgressMeter</code> and <code>OneLineProgressMeterCancel</code>.  You can easily cancel any progress meter by calling it with the current value = max value.  This will mark the meter as expired and close the window.    <br />
You've already seen OneLineProgressMeter calls presented earlier in this readme.      </p>
<pre><code>sg.OneLineProgressMeter('My Meter', i+1, 1000,  'key', 'Optional message')
</code></pre>
<p>The return value for <code>OneLineProgressMeter</code> is:    <br />
<code>True</code> if meter updated correctly    <br />
<code>False</code> if user clicked the Cancel button, closed the window, or vale reached the max value.      </p>
<h4 id="progress-mater-in-your-window">Progress Mater in Your window</h4>
<p>Another way of using a Progress Meter with PySimpleGUI is to build a custom window with a <code>ProgressBar</code> Element in the window.  You will need to run your window as a non-blocking window.  When you are ready to update your progress bar, you call the <code>UpdateBar</code> method for the <code>ProgressBar</code> element itself.      </p>
<p><img alt="progress custom" src="https://user-images.githubusercontent.com/13696193/45243969-c3508100-b2c3-11e8-82bc-927d0307e093.jpg" />      </p>
<pre><code>import PySimpleGUI as sg

# layout the window      
layout = [[sg.Text('A custom progress meter')],      
          [sg.ProgressBar(10000, orientation='h', size=(20, 20), key='progressbar')],      
          [sg.Cancel()]]

# create the window`      
window = sg.Window('Custom Progress Meter').Layout(layout)      
progress_bar = window.FindElement('progressbar')      
# loop that would normally do something useful      
for i in range(10000):      
    # check to see if the cancel button was clicked and exit loop if clicked      
  event, values = window.Read(timeout=0)      
    if event == 'Cancel'  or event is None:      
        break      
  # update bar with loop value +1 so that bar eventually reaches the maximum      
  progress_bar.UpdateBar(i + 1)      
# done with loop... need to destroy the window as it's still open      
window.Close())
</code></pre>
<h4 id="output">Output</h4>
<p>The Output Element is a re-direction of Stdout.  Anything "printed" will be displayed in this element.      </p>
<pre><code>Output(size=(None, None))
</code></pre>
<p>Here's a complete solution for a chat-window using an Async window with an Output Element      </p>
<pre><code>import PySimpleGUI as sg

# Blocking window that doesn't close      
def ChatBot():      
    layout = [[(sg.Text('This is where standard out is being routed', size=[40, 1]))],      
              [sg.Output(size=(80, 20))],      
              [sg.Multiline(size=(70, 5), enter_submits=True),      
               sg.RButton('SEND', button_color=(sg.YELLOWS[0], sg.BLUES[0])),      
               sg.Button('EXIT', button_color=(sg.YELLOWS[0], sg.GREENS[0]))]]

  window = sg.Window('Chat Window', default_element_size=(30, 2)).Layout(layout)

    # ---===--- Loop taking in user input and using it to query HowDoI web oracle --- #      
  while True:      
        event, value = window.Read()      
        if event == 'SEND':      
            print(value)      
        else:      
            break

ChatBot()
</code></pre>
<h3 id="progressbar-methods">ProgressBar Methods</h3>
<pre><code class="python">UpdateBar(current_count, max=None)    
</code></pre>

<p>current_count - sets the current value  <br />
max - changes the max value    </p>
<h2 id="column-element">Column Element</h2>
<p>Starting in version 2.9 you'll be able to do more complex layouts by using the Column Element.  Think of a Column as a window within a window.  And, yes, you can have a Column within a Column if you want.      </p>
<p>Columns are specified in exactly the same way as a window is, as a list of lists.      </p>
<pre><code class="python">Column(  layout, 
         background_color=None,
         size=(None, None), 
         pad=None, 
         scrollable=False, 
         vertical_scroll_only=False,
         right_click_menu=None, 
         key=None,
         visible=True)
</code></pre>

<p>Columns are needed when you have an element that has a height &gt; 1 line on the left, with single-line elements on the right.  Here's an example of this kind of layout:      </p>
<p><img alt="column" src="https://user-images.githubusercontent.com/13696193/44959988-66b92480-aec5-11e8-9c26-316ed24a68c0.jpg" />      </p>
<p>This code produced the above window.      </p>
<pre><code>import PySimpleGUI as sg

# Demo of how columns work      
# window has on row 1 a vertical slider followed by a COLUMN with 7 rows      
# Prior to the Column element, this layout was not possible      
# Columns layouts look identical to window layouts, they are a list of lists of elements.

window = sg.Window('Columns')                                   # blank window

# Column layout      
col = [[sg.Text('col Row 1')],      
       [sg.Text('col Row 2'), sg.Input('col input 1')],      
       [sg.Text('col Row 3'), sg.Input('col input 2')],      
       [sg.Text('col Row 4'), sg.Input('col input 3')],      
       [sg.Text('col Row 5'), sg.Input('col input 4')],      
       [sg.Text('col Row 6'), sg.Input('col input 5')],      
       [sg.Text('col Row 7'), sg.Input('col input 6')]]

layout = [[sg.Slider(range=(1,100), default_value=10, orientation='v', size=(8,20)), sg.Column(col)],      
          [sg.In('Last input')],      
          [sg.OK()]]

# Display the window and get values      
# If you're willing to not use the "context manager" design pattern, then it's possible      
# to collapse the window display and read down to a single line of code.      
event, values = sg.Window('Compact 1-line window with column').Layout(layout).Read()

sg.Popup(event, values, line_width=200)
</code></pre>
<p>The Column Element has 1 required parameter and 1 optional (the layout and the background color).  Setting the background color has the same effect as setting the window's background color, except it only affects the column rectangle.      </p>
<pre><code>Column(layout, background_color=None)
</code></pre>
<p>The default background color for Columns is the same as the default window background color.  If you change the look and feel of the window, the column background will match the window background automatically.      </p>
<hr />
<h2 id="frame-element-labelled-frames-frames-with-a-title">Frame Element (Labelled Frames, Frames with a title)</h2>
<p>Frames work exactly the same way as Columns.  You create layout that is then used to initialize the Frame.      </p>
<pre><code class="python">Frame(  title, 
        layout, 
        title_color=None, 
        background_color=None, 
        title_location=None,
        relief=DEFAULT_FRAME_RELIEF, 
        size=(None, None), 
        font=None,
        pad=None, 
        border_width=None,
        key=None, 
        tooltip=None, 
        right_click_menu=None, 
        visible=True)
</code></pre>

<pre><code>def Frame(title - the label / title to put on frame      
              layout - list of rows of elements the frame contains      
              title_color - color of the title text      
              background_color - color of background      
              title_location - locations to put the title      
              relief - type of relief to use      
              size - size of Frame in characters. Do not use if you want frame to autosize      
              font - font to use for title      
              pad - element padding  to use when packing      
              border_width - how thick the line going around frame should be      
              key - key used to location the element      
              tooltip - tooltip text
</code></pre>
<p>This code creates a window with a Frame and 2 buttons.      </p>
<pre><code>frame_layout = [      
                  [sg.T('Text inside of a frame')],      
                  [sg.CB('Check 1'), sg.CB('Check 2')],      
               ]      
layout = [      
          [sg.Frame('My Frame Title', frame_layout, font='Any 12', title_color='blue')],      
          [sg.Submit(), sg.Cancel()]      
         ]

window = sg.Window('Frame with buttons', font=("Helvetica", 12)).Layout(layout)
</code></pre>
<p><img alt="frame element" src="https://user-images.githubusercontent.com/13696193/45889173-c2245700-bd8d-11e8-8f73-1e5f1be3ddb1.jpg" />      </p>
<p>Notice how the Frame layout looks identical to a window layout.  A window works exactly the same way as a Column and a Frame.  They all are "container elements".  Elements that contain other elements.      </p>
<p><em>These container Elements can be nested as deep as you want.</em> That's a pretty spiffy feature, right?  Took a lot of work so be appreciative.  Recursive code isn't trivial.      </p>
<h2 id="canvas-element">Canvas Element</h2>
<pre><code class="python">Canvas(canvas=None,
       background_color=None, 
       size=(None, None),
       pad=None, 
       key=None, 
       tooltip=None, 
       right_click_menu=None, 
       visible=True)
</code></pre>

<p>In my opinion, the tkinter Canvas Widget is the most powerful of the tkinter widget.  While I try my best to completely isolate the user from anything that is tkinter related, the Canvas Element is the one exception.  It enables integration with a number of other packages, often with spectacular results.      </p>
<h3 id="matplotlib-pyplot-integration">Matplotlib, Pyplot Integration</h3>
<p>One such integration is with Matploplib and Pyplot.  There is a Demo program written that you can use as a design pattern to get an understanding of how to use the Canvas Widget once you get it.      </p>
<pre><code>def Canvas(canvas - a tkinter canvasf if you created one. Normally not set      
         background_color - canvas color      
         size - size in pixels      
         pad - element padding for packing      
         key - key used to lookup element      
         tooltip - tooltip text
</code></pre>
<p>The order of operations to obtain a tkinter Canvas Widget is:      </p>
<pre><code>figure_x, figure_y, figure_w, figure_h = fig.bbox.bounds      
# define the window layout      
layout = [[sg.Text('Plot test')],      
          [sg.Canvas(size=(figure_w, figure_h), key='canvas')],      
          [sg.OK(pad=((figure_w / 2, 0), 3), size=(4, 2))]]

# create the window and show it without the plot      
window = sg.Window('Demo Application - Embedding Matplotlib In PySimpleGUI').Layout(layout).Finalize()


# add the plot to the window      
fig_photo = draw_figure(window.FindElement('canvas').TKCanvas, fig)

# show it all again and get buttons      
event, values = window.Read()
</code></pre>
<p>To get a tkinter Canvas Widget from PySimpleGUI, follow these steps:    <br />
<em> Add Canvas Element to your window    <br />
</em> Layout your window    <br />
<em> Call <code>window.Finalize()</code> - this is a critical step you must not forget    <br />
</em> Find the Canvas Element by looking up using key    <br />
<em> Your Canvas Widget Object will be the found_element.TKCanvas    <br />
</em> Draw on your canvas to your heart's content    <br />
* Call <code>window.Read()</code> - Nothing will appear on your canvas until you call Read      </p>
<p>See <code>Demo_Matplotlib.py</code> for a Recipe you can copy.      </p>
<h3 id="canvas-methods">Canvas Methods</h3>
<p>TKCanvas - not a method but a property. Returns the tkinter Canvas Widget    </p>
<h2 id="graph-element">Graph Element</h2>
<p>All you math fans will enjoy this Element... and all you non-math fans will enjoy it too.      </p>
<p>I've found nothing to be less fun than dealing with a graphic's coordinate system from a GUI Framework.  It's always upside down from what I want.  (0,0) is in the upper left hand corner.  In short, it's a <strong>pain in the ass</strong>.      </p>
<p>Graph Element to the rescue.  A Graph Element creates a pixel addressable canvas using YOUR coordinate system.  <em>You</em> get to define the units on the X and Y axis.      </p>
<p>There are 3 values you'll need to supply the Graph Element.  They are:    <br />
<em> Size of the canvas in pixels    <br />
</em> The lower left (x,y) coordinate of your coordinate system    <br />
* The upper right (x,y) coordinate of your coordinate system      </p>
<p>After you supply those values you can scribble all of over your graph by creating Graph Figures.  Graph Figures are created, and a Figure ID is obtained by calling:    <br />
<em> DrawCircle    <br />
</em> DrawLine    <br />
<em> DrawPoint    <br />
</em> DrawRectangle    <br />
* DrawOval      </p>
<p>You can move your figures around on the canvas by supplying the Figure ID the x,y amount to move.      </p>
<pre><code>graph.MoveFigure(my_circle, 10, 10)
</code></pre>
<p>This Element is relatively new and may have some parameter additions or deletions.  It shouldn't break your code however.      </p>
<pre><code class="python">  Graph(canvas_size, 
        graph_bottom_left, 
        graph_top_right, 
        background_color=None, 
        pad=None,
        change_submits=False,
        drag_submits=False
        enable_events=False,
        key=None,
        tooltip=None,
        right_click_menu=None, 
        visible=True)
</code></pre>

<h3 id="graph-methods">Graph Methods</h3>
<pre><code class="python">DrawLine(self, point_from, point_to, color='black', width=1)    
DrawPoint(self, point, size=2, color='black')    
DrawCircle(self, center_location, radius, fill_color=None, line_color='black')    
DrawOval(self, top_left, bottom_right, fill_color=None, line_color=None)    
DrawArc(self, top_left, bottom_right, extent, start_angle, style=None, arc_color='black')    
DrawRectangle(self, top_left, bottom_right, fill_color=None, line_color=None)    
DrawText(self, text, location, color='black', font=None, angle=0)    
Erase(background_color)    
DeleteFigure(figure_id)
Update()    
Move(self, x_direction, y_direction)    
MoveFigure(self, figure, x_direction, y_direction)    
TKCanvas    
</code></pre>

<p>All of the Drawing methods return a "<strong><em>figure</em></strong>" that can be used move and delete the figure    </p>
<p>DrawLine - draws a line  <br />
DrawPoint - draws a single point  <br />
DrawCircle - draws a circle  <br />
DrawOval - draws an oval  <br />
DrawArc - draws an arc  <br />
DrawRectangle - draws a rectangle  <br />
DrawText - draws text  <br />
Erase - erases entire graph  <br />
Update - changes background color  <br />
Move - moves everything an x,y direction  <br />
MoveFigure - moves an individual figure  <br />
DeleteFigure - delete an individual figure</p>
<h2 id="table-element">Table Element</h2>
<p>Out of all of the Elements, it's the Table and the Tree that are the most "problematic" in the tkinter inter and Qt implementations.  They're hard is my only defense.</p>
<h3 id="known-visualization-problem">Known visualization problem....</h3>
<p>If you click on the header, it can go into spasms for some tables. I don't understand what's causing it and it's been there evidently since the first release of Tables.</p>
<pre><code class="python">Table(  values,
        headings=None,
        visible_column_map=None,
        col_widths=None,
        def_col_width=10,
        auto_size_columns=True,
        max_col_width=20,
        select_mode=None,
        display_row_numbers=False,
        num_rows=None,
        row_height=None,
        font=None,
        justification='right',
        text_color=None,
        background_color=None,
        alternating_row_color=None,
        row_colors=None,
        vertical_scroll_only=True,
        size=(None,None),
        change_submits=False,
        enable_events=False,
        bind_return_key=False,
        pad=None,
        key=None,
        tooltip=None,
        right_click_menu=None,
        visible=True):

</code></pre>

<p>values - Your table's array    <br />
headings - list of strings representing your headings, if you have any    <br />
visible_column_map - list of bools. If True, column in that position is shown.  Defaults to all columns    <br />
col_widths - list of column widths    <br />
def_col_width - default column width. defaults to 10    <br />
auto_size_columns - bool. If True column widths are determined by table contents    <br />
max_col_width - maximum width of a column. defaults to 25    <br />
select_mode - table rows can be selected, but doesn't currently do anything    <br />
display_row_numbers - bool. If True shows numbers next to rows
num_rows = the number of rows to display at a time (same as size[0])    <br />
row_height = number of pixels high a row should be. Normally left as default value<br />
font - font for table entries    <br />
justification - left, right, center    <br />
text_color - color of text    <br />
alternating row color - if set will change background color for alternating rows
row_colors - list of tuples representing (row_number, color) e.g. row_colors = ((5, 'white', 'blue'), (0,'red'), (15,'yellow'))
vertical_scroll_only - if True will not show a horizontal scrollbar.   NOTE - will have to disable to get horizontal scrollbars
background_color - cell background color    <br />
size - (None, number of rows) - don't use, use num_rows instead
enable_events - will return a 'row selected' event when row is selected
change_submits - the old way of indicating enable_events
bind_return_key - returns event if a double click or a return key is pressed while row is highlighted
pad - element padding for packing    <br />
key - key used to lookup element    <br />
tooltip - tooltip text      </p>
<h3 id="read-return-values-from-table-element">Read return values from Table Element</h3>
<p>The values returned from a <code>Window.Read</code> call for the Tree Element are a list of row numbers that are currently highlighted.</p>
<h3 id="update-call">Update Call</h3>
<p>The Update method can be used to make changes to a table that's already been displayed.  The call takes a single parameter, values, which is the new table to display.  The entire table is replaced.</p>
<pre><code class="python">def Update(self, values=None):
</code></pre>

<p><code>values</code> is a table containing your rows just like you passed in when creating the Table Element.</p>
<h2 id="tree-element">Tree Element</h2>
<p>The Tree Element and Table Element are close cousins.   Many of the parameters found in the Table Element apply to Tree Elements.  In particular the heading information, column widths, etc.    </p>
<pre><code class="python">Tree(   data=None,
        headings=None, 
        visible_column_map=None, 
        col_widths=None, 
        col0_width=10,
        def_col_width=10,
        auto_size_columns=True, 
        max_col_width=20, 
        select_mode=None, 
        show_expanded=False, 
        change_submits=False, 
        enable_events=False, 
        font=None,
        justification='right', 
        text_color=None, 
        background_color=None,
        num_rows=None,
        row_height=None,
        pad=None, 
        key=None, 
        tooltip=None,
        right_click_menu=None, 
        visible=True)
</code></pre>

<pre><code>class Tree(data=None - data in TreeData format    
         headings=None - list of strings representing your headings    
         visible_column_map=None - list of bools indicating which columns to display    
         col_widths=None - list of column widths    
         col0_width=10 - width of the first column which has the text data    
         def_col_width=10 - default column width    
         auto_size_columns=True - if true will autosize columns (currenly only sizes to col heading width)    
         max_col_width=20 - max width for columns in characters    
         select_mode=None - not yet used    
         show_expanded - Bool - if True the tree will be fully expanded when shown
         font=None - the display font    
         justification='right' - justification for data display    
         text_color=None- color of text to display    
         background_color=None - background color    
         num_rows=None - number of rows to display   
         row_height=None - height of rows in pixels 
         pad=None - element padding    
         key=None - key for element    
         tooltip=None - tooltip    
</code></pre>

<p>Unlike Tables there is no standard format for trees.  Thus the data structure passed to the Tree Element must be constructed.  This is done using the TreeData class.  The process is as follows:  <br />
<em> Get a TreeData Object  <br />
</em> "Insert" data into the tree  <br />
* Pass the filled in TreeData object to Tree Element    </p>
<h4 id="treedata-format">TreeData format</h4>
<pre><code class="python">def TreeData()
def Insert(self, parent, key, text, values, icon=None)
</code></pre>

<p>To "insert" data into the tree the TreeData method Insert is called.    </p>
<p><code>Insert(parent_key, key, display_text, values)</code>    </p>
<p>To indicate insertion at the head of the tree, use a parent key of "".  So, every top-level node in the tree will have a parent node = ""    </p>
<p>This code creates a TreeData object and populates with 3 values    </p>
<pre><code class="python">treedata = sg.TreeData()    

treedata.Insert(&quot;&quot;, '_A_', 'A', [1,2,3])      
treedata.Insert(&quot;&quot;, '_B_', 'B', [4,5,6])      
treedata.Insert(&quot;_A_&quot;, '_A1_', 'A1', ['can','be','anything'])    
</code></pre>

<p>Note that you <strong><em>can</em></strong> use the same values for display_text and keys.  The only thing you have to watch for is that you cannot repeat keys.    </p>
<p>When Reading a window the Table Element will return a list of rows that are selected by the user.  The list will be empty is no rows are selected.    </p>
<h4 id="icons-on-tree-entries">Icons on Tree Entries</h4>
<p>If you wish to show an icon next to a tree item, then you specify the icon in the call to <code>Insert</code>.  You pass in a filename or a Base64 bytes string using the optional <code>icon</code> parameter.</p>
<p>Here is the result of showing an icon with a tree entry.</p>
<p><img alt="image" src="https://user-images.githubusercontent.com/13696193/51087270-2b561e80-171f-11e9-8260-6142ea9b1137.png" /></p>
<h2 id="tab-and-tab-group-elements">Tab and Tab Group Elements</h2>
<p>Tabs have been a part of PySimpleGUI since the initial release.  However, the initial implementation applied tabs at the top level only. The entire window had to be tabbed.  There with other limitations that came along with that implementation.  That all changed in version 3.8.0 with the new elements - Tab and TabGroup.  The old implementation of Tabs was removed in version 3.8.0 as well.      </p>
<p>Tabs are another "Container Element".  The other Container Elements include:    <br />
<em> Frame    <br />
</em> Column      </p>
<p>You layout a Frame in exactly the same way as a Frame or Column elements, by passing in a list of elements.      </p>
<p>How you place a Tab into a Window is different than Graph or Frame elements.  You cannot place a tab directly into a Window's layout.  It much first be placed into a TabGroup.  The  TabGroup can then be placed into the Window.      </p>
<p>Let's look at this Window as an example:      </p>
<p><img alt="tabbed 1" src="https://user-images.githubusercontent.com/13696193/45992808-b10f6a80-c059-11e8-9746-ac71afd4d3d6.jpg" />      </p>
<p>View of second tab:      </p>
<p><img alt="tabbed 2" src="https://user-images.githubusercontent.com/13696193/45992809-b10f6a80-c059-11e8-94e6-3bf543c9b0bd.jpg" />      </p>
<p>First we have the Tab layout definitions. They mirror what you see in the screen shots.  Tab 1 has 1 Text Element in it.  Tab 2 has a Text and an Input Element.      </p>
<pre><code>tab1_layout =  [[sg.T('This is inside tab 1')]]

tab2_layout = [[sg.T('This is inside tab 2')],      
               [sg.In(key='in')]]
</code></pre>
<p>The layout for the entire window looks like this:      </p>
<pre><code>layout = [[sg.TabGroup([[sg.Tab('Tab 1', tab1_layout), sg.Tab('Tab 2', tab2_layout)]])],      
          [sg.RButton('Read')]]
</code></pre>
<p>The Window layout has the TabGroup and within the tab Group are the two Tab elements.      </p>
<p>One important thing to notice about all of these container Elements... they all take a "list of lists" at the layout.  They all have a layout that starts with <code>[[</code>      </p>
<p>You will want to keep this <code>[[ ]]</code> construct in your head a you're debugging your tabbed windows.  It's easy to overlook one or two necessary ['s      </p>
<p>As mentioned earlier, the old-style Tabs were limited to being at the Window-level only.  In other words, the tabs were equal in size to the entire window.  This is not the case with the "new-style" tabs.  This is why you're not going to be upset when you discover your old code no longer works with the new PySimpleGUI release.  It'll be worth the few moments it'll take to convert your code.      </p>
<p>Check out what's possible with the NEW Tabs!      </p>
<p><img alt="tabs tabs tabs" src="https://user-images.githubusercontent.com/13696193/45993438-fd0fde80-c05c-11e8-9ed0-742f14d3070f.jpg" />      </p>
<p>Check out Tabs 7 and 8.  We've got a Window with a Column containing Tabs 5 and 6.  On Tab 6 are... Tabs 7 and 8.      </p>
<p>As of Release 3.8.0, not all of <em>options</em> shown in the API definitions of the Tab and TabGroup Elements are working. They are there as placeholders.      </p>
<p>The definition of a TabGroup is      </p>
<pre><code> TabGroup(layout,      
           title_color=None      
           background_color=None      
           font=None      
           pad=None      
           border_width=None      
           change_submits = False      
           key=None      
           tooltip=None)
</code></pre>
<p>The definition of a Tab Element is      </p>
<pre><code>Tab(title,      
    layout,      
    title_color=None,      
    background_color=None,      
    font=None,      
    pad=None      
    disabled=False    
    border_width=None      
    key=None      
    tooltip=None)
</code></pre>
<h3 id="reading-tab-groups">Reading Tab Groups</h3>
<p>Tab Groups now return a value when a Read returns.  They return which tab is currently selected.  There is also a change_submits parameter that can be set that causes a Read to return if a Tab in that group is selected / changed.  The key or title belonging to the Tab that was switched to will be returned as the value      </p>
<h3 id="tab-element-methods">Tab Element Methods</h3>
<pre><code class="python">Update(disabled = None, visible=None)    
</code></pre>

<p>WARNING - This Update method may not be working correctly</p>
<h2 id="pane-element">Pane Element</h2>
<p>New in version 3.20 is the Pane Element, a super-cool tkinter feature.  You won't find this one in PySimpleGUIQt, only PySimpleGUI.   It's difficult to describe one of these things.  Think of them as "Tabs without labels" that you can slide.</p>
<p><img alt="pane3" src="https://user-images.githubusercontent.com/13696193/50035040-fcd50e80-ffcd-11e8-939c-df8ab8d64712.gif" /></p>
<pre><code class="python">
Pane(pane_list, background_color=None, size=(None, None), pad=None, orientation='vertical', show_handle=True, relief=RELIEF_RAISED, handle_size=None, border_width=None, key=None, visible=True):
</code></pre>

<p><strong><em>Each "Pane" of a Pane Element must be a Column Element</em></strong>.  The parameter <code>pane_list</code> is a list of Column Elements.</p>
<p>Calls can get a little hairy looking if you try to declare everything in-line as you can see in this example.</p>
<pre><code class="python">sg.Pane([col5, sg.Column([[sg.Pane([col1, col2, col4], handle_size=15, orientation='v',  background_color=None, show_handle=True, visible=True, key='_PANE_', border_width=0,  relief=sg.RELIEF_GROOVE),]]),col3 ], orientation='h', background_color=None, size=(160,160), relief=sg.RELIEF_RAISED, border_width=0)
</code></pre>

<p>Combing these with <em>visibility</em> make for an interesting interface with entire panes being hidden from view until neded by the user.  It's one way of producing "dynamic" windows.</p>
<h2 id="colors_1">Colors</h2>
<p>Starting in version 2.5 you can change the background colors for the window and the Elements.      </p>
<p>Your windows can go from this:      </p>
<p><img alt="snap0155" src="https://user-images.githubusercontent.com/13696193/43273879-a9fdc10a-90cb-11e8-8c20-4f6a244ebe2f.jpg" />      </p>
<p>to this... with one function call...      </p>
<p><img alt="snap0156" src="https://user-images.githubusercontent.com/13696193/43273880-aa1955e6-90cb-11e8-94b6-673ecdb2698c.jpg" />      </p>
<p>While you can do it on an element by element or window level basis, the easiest way, by far, is a call to <code>SetOptions</code>.      </p>
<p>Be aware that once you change these options they are changed for the rest of your program's execution.  All of your windows will have that look and feel, until you change it to something else (which could be the system default colors.      </p>
<p>This call sets all of the different color options.      </p>
<pre><code>SetOptions(background_color='#9FB8AD',      
           text_element_background_color='#9FB8AD',      
           element_background_color='#9FB8AD',      
           scrollbar_color=None,      
           input_elements_background_color='#F7F3EC',      
           progress_meter_color = ('green', 'blue')      
           button_color=('white','#475841'))
</code></pre>
<h1 id="systemtray">SystemTray</h1>
<p>This is a PySimpleGUIQt and PySimpleGUIWx only feature.  Don't know of a way to do it using tkinter.  Your source code for SystemTray is identical for the Qt and Wx implementations.  You can switch frameworks by simply changing your import statement.</p>
<p>In addition to running normal windows, it's now also possible to have an icon down in the system tray that you can read to get menu events.  There is a new SystemTray object that is used much like a Window object.  You first get one, then  you perform Reads in order to get events.</p>
<p>Here is the definition of the SystemTray object.</p>
<pre><code class="python">SystemTray(menu=None, filename=None, data=None, data_base64=None, tooltip=None):  
        '''  
 SystemTray - create an icon in the system tray  
 :param menu: Menu definition 
 :param filename: filename for icon  
 :param data: in-ram image for icon  
 :param data_base64: basee-64 data for icon  
 :param tooltip: tooltip string '''
</code></pre>

<p>You'll notice that there are 3 different ways to specify the icon image.  The base-64 parameter allows you to define a variable in your .py code that is the encoded image so that you do not need any additional files.  Very handy feature.</p>
<h2 id="system-tray-design-pattern">System Tray Design Pattern</h2>
<p>Here is a design pattern you can use to get a jump-start.</p>
<p>This program will create a system tray icon and perform a blocking Read.  If the item "Open" is chosen from the system tray, then a popup is shown.</p>
<pre><code class="python">import PySimpleGUIQt as sg  

menu_def = ['BLANK', ['&amp;Open', '---', '&amp;Save', ['1', '2', ['a', 'b']], '&amp;Properties', 'E&amp;xit']]  

tray = sg.SystemTray(menu=menu_def, filename=r'default_icon.ico')  

while True:  # The event loop  
  menu_item = tray.Read()  
    print(menu_item)  
    if menu_item == 'Exit':  
        break  
    elif menu_item == 'Open':  
        sg.Popup('Menu item chosen', menu_item)

</code></pre>

<p>The design pattern creates an icon that will display this menu:
<img alt="snag-0293" src="https://user-images.githubusercontent.com/13696193/49057441-8bbfe980-f1cd-11e8-93e7-1aeda9ccd173.jpg" /></p>
<h3 id="icons">Icons</h3>
<p>When specifying "icons", you can use 3 different formats.<br />
<em> <code>filename</code>- filename
</em> <code>data_base64</code> - base64 byte string
* '<code>data</code> - in-ram bitmap or other "raw" image</p>
<p>You will find 3 parameters used to specify these 3 options on both the initialize statement and on the Update method.</p>
<h2 id="menu-definition">Menu Definition</h2>
<pre><code class="python">menu_def = ['BLANK', ['&amp;Open', '&amp;Save', ['1', '2', ['a', 'b']], '!&amp;Properties', 'E&amp;xit']]  
</code></pre>

<p>A menu is defined using a list.  A "Menu entry" is a string that specifies:
<em> text shown
</em> keyboard shortcut
* key</p>
<p>See section on Menu Keys for more information on using keys with menus.</p>
<p>An entry without a key and keyboard shortcut is a simple string
<code>'Menu Item'</code></p>
<p>If you want to make the "M" be a keyboard shortcut, place an <code>&amp;</code> in front of the letter that is the shortcut.
<code>'&amp;Menu Item'</code></p>
<p>You can add "keys" to make menu items unique or as another way of identifying a menu item than the text shown.  The key is added to the text portion by placing <code>::</code> after the text.</p>
<p><code>'Menu Item::key'</code></p>
<p>The first entry can be ignored.<code>'BLANK</code>' was chosen for this example. It's this way because normally you would specify these menus under some heading on a menu-bar.  But here there is no heading so it's filled in with any value you want.</p>
<p><strong>Separators</strong>
If you want a separator between 2 items, add the entry <code>'---'</code> and it will add a separator item at that place in your menu.</p>
<p><strong>Disabled menu entries</strong></p>
<p>If you want to disable a menu entry, place a <code>!</code> before the menu entry</p>
<h2 id="systemtray-methods">SystemTray Methods</h2>
<h3 id="read-read-the-context-menu-or-check-for-events">Read - Read the context menu or check for events</h3>
<pre><code class="python">def Read(timeout=None)
    '''  
 Reads the context menu  
 :param timeout: Optional.  Any value other than None indicates a non-blocking read
 :return:   String representing meny item chosen. None if nothing read.  
    '''
</code></pre>

<p>The <code>timeout</code> parameter specifies how long to wait for an event to take place.  If nothing happens within the timeout period, then a "timeout event" is returned.  These types of reads make it possible to run asynchronously.  To run non-blocked, specify <code>timeout=0</code>on the Read call.</p>
<p>Read returns the menu text, complete with key, for the menu item chosen.  If you specified <code>Open::key</code> as the menu entry, and the user clicked on <code>Open</code>, then you will receive the string <code>Open::key</code> upon completion of the Read.</p>
<h4 id="read-special-return-values">Read special return values</h4>
<p>In addition to Menu Items, the Read call can return several special values.    They include:</p>
<p>EVENT_SYSTEM_TRAY_ICON_DOUBLE_CLICKED - Tray icon was double clicked
EVENT_SYSTEM_TRAY_ICON_ACTIVATED - Tray icon was single clicked
EVENT_SYSTEM_TRAY_MESSAGE_CLICKED - a message balloon was clicked
TIMEOUT_KEY is returned if no events are available if the timeout value is set in the Read call</p>
<h3 id="hide_1">Hide</h3>
<p>Hides the icon.  Note that no message balloons are shown while an icon is hidden.</p>
<pre><code class="python">def Hide() 
</code></pre>

<h3 id="close_1">Close</h3>
<p>Does the same thing as hide</p>
<pre><code class="python">def Close()
</code></pre>

<h3 id="unhide_1">UnHide</h3>
<p>Shows a previously hidden icon</p>
<pre><code class="python">def UnHide()
</code></pre>

<h3 id="showmessage">ShowMessage</h3>
<p>Shows a balloon above the icon in the system tray area.  You can specify your own icon to be shown in the balloon, or you can set <code>messageicon</code> to one of the preset values.  </p>
<p>This message has a custom icon.</p>
<p><img alt="snag-0286" src="https://user-images.githubusercontent.com/13696193/49057459-a85c2180-f1cd-11e8-9a66-aa331d7e034c.jpg" /></p>
<p>The preset <code>messageicon</code> values are:</p>
<pre><code>SYSTEM_TRAY_MESSAGE_ICON_INFORMATION 
SYSTEM_TRAY_MESSAGE_ICON_WARNING
SYSTEM_TRAY_MESSAGE_ICON_CRITICAL 
SYSTEM_TRAY_MESSAGE_ICON_NOICON
</code></pre>
<pre><code class="python">ShowMessage(title, message, filename=None, data=None, data_base64=None, messageicon=None, time=10000):  
    '''  
 Shows a balloon above icon in system tray  
 :param title:  Title shown in balloon  
 :param message: Message to be displayed  
 :param filename: Optional icon filename  
 :param data: Optional in-ram icon  
 :param data_base64: Optional base64 icon  
 :param time: How long to display message in milliseconds  :return:  
 '''
</code></pre>

<p>Note, on windows it may be necessary to make a registry change to enable message balloons to be seen.  To fix this, you must create the DWORD you see in this screenshot.</p>
<p><img alt="snag-0285" src="https://user-images.githubusercontent.com/13696193/49056144-6381bc00-f1c8-11e8-9f44-199394823369.jpg" /></p>
<h3 id="update_1">Update</h3>
<p>You can update any of these items within a SystemTray object
<em> Menu definition
</em> Icon
* Tooltip</p>
<p>Change them all or just 1.</p>
<pre><code class="python">Update(menu=None, tooltip=None,filename=None, data=None, data_base64=None,)
    '''  
 Updates the menu, tooltip or icon  
 :param menu: menu defintion  
 :param tooltip: string representing tooltip  
 :param filename:  icon filename  
 :param data:  icon raw image  
 :param data_base64: icon base 64 image  
 :return:  
 '''
</code></pre>

<h1 id="global-settings">Global Settings</h1>
<p><strong>Global Settings</strong>    <br />
Let's have some fun customizing!  Make PySimpleGUI look the way you want it to look. You can set the global settings using the function <code>PySimpleGUI.SetOptions</code>.  Each option has an optional parameter that's used to set it.      </p>
<pre><code>SetOptions(icon=None      
        button_color=(None,None)      
        element_size=(None,None),      
        margins=(None,None),      
        element_padding=(None,None)      
        auto_size_text=None      
        auto_size_buttons=None      
        font=None      
        border_width=None      
        slider_border_width=None      
        slider_relief=None      
        slider_orientation=None      
        autoclose_time=None      
        message_box_line_width=None      
        progress_meter_border_depth=None      
        progress_meter_style=None      
        progress_meter_relief=None      
        progress_meter_color=None      
        progress_meter_size=None      
        text_justification=None      
        text_color=None      
        background_color=None      
        element_background_color=None      
        text_element_background_color=None      
        input_elements_background_color=None      
        element_text_color=None      
        input_text_color=None      
        scrollbar_color=None, text_color=None      
        debug_win_size=(None,None)      
        window_location=(None,None)      
        tooltip_time = None
</code></pre>
<p>Explanation of parameters      </p>
<pre><code>         icon - filename of icon used for taskbar and title bar      
         button_color - button color (foreground, background)      
         element_size - element size (width, height) in characters      
         margins - tkinter margins around outsize      
         element_padding - tkinter padding around each element      
         auto_size_text - autosize the elements to fit their text      
         auto_size_buttons - autosize the buttons to fit their text      
         font - font used for elements      
         border_width - amount of bezel or border around sunken or raised elements      
         slider_border_width - changes the way sliders look      
         slider_relief - changes the way sliders look      
         slider_orientation - changes orientation of slider      
         autoclose_time - time in seconds for autoclose boxes      
         message_box_line_width - number of characers in a line of text in message boxes      
         progress_meter_border_depth - amount of border around raised or lowered progress meters      
         progress_meter_style - style of progress meter as defined by tkinter      
         progress_meter_relief - relief style      
         progress_meter_color - color of the bar and background of progress meters      
         progress_meter_size - size in (characters, pixels)      
         background_color - Color of the main window's background      
         element_background_color - Background color of the elements      
         text_element_background_color - Text element background color      
         input_elements_background_color - Input fields background color      
         element_text_color - Text color of elements that have text, like Radio Buttons      
         input_text_color - Color of the text that you type in      
         scrollbar_color - Color for scrollbars (may not always work)      
         text_color - Text element default text color      
         text_justification - justification to use on Text Elements. Values are strings - 'left', 'right', 'center'      
         debug_win_size - size of the Print output window      
         window_location - location on the screen (x,y) of window's top left cornder      
         tooltip_time - time in milliseconds to wait before showing a tooltip. Default is 400ms
</code></pre>
<p>These settings apply to all windows <code>SetOptions</code>.  The Row options and Element options will take precedence over these settings.  Settings can be thought of as levels of settings with the window-level being the highest and the Element-level the lowest.  Thus the levels are:      </p>
<ul>
<li>window level      </li>
<li>Row level      </li>
<li>Element level      </li>
</ul>
<p>Each lower level overrides the settings of the higher level.  Once settings have been changed, they remain changed for the duration of the program (unless changed again).      </p>
<h1 id="persistent-windows-window-stays-open-after-button-click">Persistent windows (Window stays open after button click)</h1>
<p>Apologies that the next few pages are perhaps confusing.  There have been a number of changes recently in PySimpleGUI's Read calls that added some really cool stuff, but at the expense of being not so simple.  Part of the issue is an attempt to make sure existing code doesn't break.  These changes are all in the area of non-blocking reads and reads with timeouts.</p>
<p>There are 2 ways to keep a window open after the user has clicked a button.  One way is to use non-blocking windows (see the next section).  The other way is to use buttons that 'read' the window instead of 'close' the window when clicked.  The typical buttons you find in windows, including the shortcut buttons, close the window.  These include OK, Cancel, Submit, etc.  The Button Element also closes the window.      </p>
<p>The <code>RButton</code> Element creates a button that when clicked will return control to the user, but will leave the window open and visible.  This button is also used in Non-Blocking windows.  The difference is in which call is made to read the window.  The normal <code>Read</code> call with no parameters will block, a call with a <code>timeout</code> value of zero will not block.</p>
<p>Note that <code>InputText</code> and <code>MultiLine</code> Elements will be <strong>cleared</strong>   when performing a <code>Read</code>.  If you do not want your input field to be cleared after a <code>Read</code> then you can set the <code>do_not_clear</code> parameter to True when creating those elements. The clear is turned on and off on an element by element basis.  </p>
<p>The reasoning behind this is that Persistent Windows are often "forms".  When "submitting" a form you want to have all of the fields left blank so the next entry of data will start with a fresh window.  Also, when implementing a "Chat Window" type of interface, after each read / send of the chat data, you want the input field cleared.  Think of it as a Texting application.  Would you want to have to clear your previous text if you want to send a second text?</p>
<p>The design pattern for Persistent Windows was already shown to you earlier in the document... here it is for your convenience.</p>
<pre><code class="python">import PySimpleGUI as sg      

layout = [[sg.Text('Persistent window')],      
          [sg.Input()],      
          [sg.RButton('Read'), sg.Exit()]]      

window = sg.Window('Window that stays open').Layout(layout)      

while True:      
    event, values = window.Read()      
    if event is None or event == 'Exit':      
        break      
    print(event, values)    

window.Close()
</code></pre>

<h2 id="readtimeout-t-timeout_keytimeout">Read(timeout = t, timeout_key='timeout')</h2>
<p>Read with a timeout is a very good thing for your GUIs to use in a read non-blocking situation, if you can use them.  If your device can wait for a little while, then use this kind of read.  The longer you're able to add to the timeout value, the less CPU time you'll be taking.</p>
<p>One way of thinking of reads with timeouts:  </p>
<blockquote>
<p>During the timeout time, you are "yielding" the processor to do other tasks.  </p>
</blockquote>
<p>But it gets better than just being a good citizen....<strong>your GUI will be more responsive than if you used a non-blocking read</strong></p>
<p>Let's say you had a device that you want to "poll" every 100ms.   The "easy way out" and the only way out until recently was this:</p>
<pre><code class="python"># YOU SHOULD NOT DO THIS....
while True:             # Event Loop  
    event, values = window.ReadNonBlocking()   # DO NOT USE THIS CALL ANYMORE
    read_my_hardware() # process my device here  
    time.sleep(.1)     # sleep 1/10 second
</code></pre>

<p>This program will quickly test for user input, then deal with the hardware.  Then it'll sleep for 100ms, while your gui is non-responsive, then it'll check in with your GUI again.  I fully realize this is a crude way of doing things.  We're talking dirt simple stuff without trying to use threads, etc to 'get it right'.  It's for demonstration purposes.</p>
<p>The new and better way.... 
using the Read Timeout mechanism, the sleep goes away.</p>
<pre><code class="python"># This is the right way to poll for hardware
while True:             # Event Loop  
    event, values = window.Read(timeout = 100) 
    read_my_hardware() # process my device here
</code></pre>

<p>This event loop will run every 100 ms.  You're making a Read call, so anything that the use does will return back to you immediately, and you're waiting up to 100ms for the user to do something.  If the user doesn't do anything, then the read will timeout and execution will return to the program.</p>
<h2 id="non-blocking-windows-asynchronous-reads">Non-Blocking Windows   (Asynchronous reads)</h2>
<p>There are TWO ways to perform a non-blocking read.</p>
<p>The "old way" was:</p>
<pre><code class="python">event, values = sg.ReadNonBlocking()
</code></pre>

<p>The new way</p>
<pre><code class="python">event, values = sg.Read(timeout=0)
</code></pre>

<p>You should use the new way if you're reading this for the first time.</p>
<p>The difference in the 2 calls is in the value of event.  For ReadNonBlocking, event will be <code>None</code> if there are no other events to report.  There is a "problem" with this however.  With normal Read calls, an event value of None signified the window was closed.  For ReadNonBlocking, the way a closed window is returned is via the values variable being set to None.  </p>
<h2 id="sgtimeout_key">sg.TIMEOUT_KEY</h2>
<p>If you're using the new, timeout=0 method, then an event value of None signifies that the window was closed, just like a normal Read.  That leaves the question of what it is set to when not other events are happening.  This value will be the value of <code>timeout_key</code>.  If you did not specify a timeout_key value in your call to read, then it will be set to a default value of:
TIMEOUT_KEY = '<strong>timeout</strong>'</p>
<p>If you wanted to test for "no event" in your loop, it would be written like this:</p>
<pre><code class="python">while True:  
    event, value = window.Read(timeout=0)  
    if event is None:  
        break # the use has closed the window  
    if event == sg.TIMEOUT_KEY:  
        print(&quot;Nothing happened&quot;)
</code></pre>

<p>Use async windows sparingly.  It's possible to have a window that appears to be async, but it is not.  <strong>Please</strong> try to find other methods before going to async windows.  The reason for this plea is that async windows poll tkinter over and over.  If you do not have a sleep in your loop, you will eat up 100% of the CPU time.      It's important to be a good citizen.   Don't chew up CPU cycles needlessly.</p>
<p>Non-blocking is generally reserved as a "last resort".  Too many times people use non-blocking reads when a blocking read will do just fine.</p>
<p>There is a hybrid approach... a read with a timeout.   You'll score much higher points on the impressive meter if you're able to use a lot less CPU time by using this type of read.</p>
<p>The most legit time to use a non-blocking window is when you're working directly with hardware.  Maybe you're driving a serial bus.  If you look at the Event Loop in the Demo_OpenCV_Webcam.py program, you'll see that the read is a non-blocking read.  However, there is a place in the event loop where blocking occurs.   The point in the loop where you will block is the call to read frames from the webcam.  When a frame is available you want to quickly deliver it to the output device, so you don't want your GUI blocking.  You want the read from the hardware to block.</p>
<p>Another example can be found in the demo for controlling a robot on a Raspberry Pi.  In that application you want to read the direction buttons, forward, backward, etc, and immediately take action.  If you are using RealtimeButtons, your only option at the moment is to use non-blocking windows.  You have to set the timeout to zero if you want the buttons to be real-time responsive.</p>
<p>However, with these buttons, adding a sleep to your event loop will at least give other processes time to execute.  It will, however, starve your GUI. The entire time you're sleeping, your GUI isn't executing.</p>
<h3 id="periodically-callingread">Periodically Calling<code>Read</code></h3>
<p>Let's say you do end up using non-blocking reads... then you've got some housekeeping to do.  It's up to you to periodically "refresh" the visible GUI.  The longer you wait between updates to your GUI the more sluggish your windows will feel.  It is up to you to make these calls or your GUI will freeze.      </p>
<p>There are 2 methods of interacting with non-blocking windows.    <br />
1. Read the window just as you would a normal window    <br />
2. "Refresh" the window's values without reading the window. It's a quick operation meant to show the user the latest values      </p>
<p>With asynchronous windows the window is shown, user input is read, but your code keeps right on chugging.  YOUR responsibility is to call <code>PySimpleGUI.Read</code> on a periodic basis.  Several times a second or more will produce a reasonably snappy GUI.      </p>
<p>## Exiting (Closing) a Persistent Window</p>
<p>If your window has a button that closes the window, then PySimpleGUI will automatically close the window for you.  If all of your buttons are ReadButtons, then it'll be up to you to close the window when done.<br />
To close a window, call the <code>Close</code> method.</p>
<pre><code class="python">window.Close()
</code></pre>

<h2 id="persistent-window-example-running-timer-that-updates">Persistent Window Example - Running timer that updates</h2>
<p>See the sample code on the GitHub named Demo Media Player for another example of Async windows.  We're going to make a window and update one of the elements of that window every .01 seconds.    Here's the entire code to do that.      </p>
<pre><code class="python">    import PySimpleGUI as sg  
    import time  

    # ----------------  Create Form  ----------------  
    sg.ChangeLookAndFeel('Black')  
    sg.SetOptions(element_padding=(0, 0))  

    layout = [[sg.Text('')],  
             [sg.Text('', size=(8, 2), font=('Helvetica', 20), justification='center', key='text')],  
             [sg.ReadButton('Pause', key='button', button_color=('white', '#001480')),  
              sg.ReadButton('Reset', button_color=('white', '#007339'), key='Reset'),  
              sg.Exit(button_color=('white', 'firebrick4'), key='Exit')]]  

    window = sg.Window('Running Timer', no_titlebar=True, auto_size_buttons=False, keep_on_top=True, grab_anywhere=True).Layout(layout)  

    # ----------------  main loop  ----------------  
    current_time = 0  
    paused = False  
    start_time = int(round(time.time() * 100))  
    while (True):  
        # --------- Read and update window --------  
        event, values = window.Read(timeout=10)  
        current_time = int(round(time.time() * 100)) - start_time  
        # --------- Display timer in window --------  
        window.FindElement('text').Update('{:02d}:{:02d}.{:02d}'.format((current_time // 100) // 60,  
                                                                      (current_time // 100) % 60,  
                                                                      current_time % 100))
</code></pre>

<p>Previously this program was implemented using a sleep in the loop to control the clock tick.  This version uses the new timeout parameter.  The result is a window that reacts quicker then the one with the sleep and the accuracy is just as good. </p>
<h2 id="instead-of-a-non-blocking-read-use-change_submits-true-or-return_keyboard_events-true">Instead of a Non-blocking Read --- Use <code>change_submits = True</code> or return_keyboard_events = True</h2>
<p>Any time you are thinking "I want an X Element to cause a Y Element to do something", then you want to use the <code>change_submits</code> option.      </p>
<p><strong><em>Instead of polling, try options that cause the window to return to you.</em></strong>  By using non-blocking windows, you are <em>polling</em>.  You can indeed create your application by polling.  It will work.  But you're going to be maxing out your processor and may even take longer to react to an event than if you used another technique.      </p>
<p><strong>Examples</strong>      </p>
<p>One example is you have an input field that changes as you press buttons on an on-screen keypad.      </p>
<p><img alt="keypad 3" src="https://user-images.githubusercontent.com/13696193/45260275-a2198e80-b3b0-11e8-85fe-a4ce6484510f.jpg" />      </p>
<h1 id="updating-elements-changing-elements-in-active-window">Updating Elements (changing elements in active window)</h1>
<p>If you want to change Elements in your window after the window has been created, then you will call the Element's Update method.</p>
<p><strong>NOTE</strong> a window <strong>must be Read or Finalized</strong> before any Update calls can be made.  </p>
<p>Here is an example of updating a Text Element</p>
<pre><code class="python">import PySimpleGUI as sg  

layout = [ [sg.Text('My layout', key='_TEXT_')],  
           [sg.Button('Read')]]  

window = sg.Window('My new window').Layout(layout)  

while True:             # Event Loop  
  event, values = window.Read()  
    if event is None:  
        break  
  window.Element('_TEXT_').Update('My new text value')
</code></pre>

<p>Notice the placement of the Update call.  If you wanted to Update the Text Element <em>prior</em> to the Read call, outside of the event loop, then you must call Finalize on the window first.</p>
<p>In this example, the Update is done prior the Read.  Because of this, the Finalize call is added to the Window creation.</p>
<pre><code class="python">import PySimpleGUI as sg  

layout = [ [sg.Text('My layout', key='_TEXT_')],  
           [sg.Button('Read')]  
         ]  

window = sg.Window('My new window').Layout(layout).Finalize()  

window.Element('_TEXT_').Update('My new text value')  

while True:             # Event Loop  
  event, values = window.Read()  
    if event is None:  
        break
</code></pre>

<p>Persistent windows remain open and thus continue to interact with the user after the Read has returned.  Often the program wishes to communicate results (output information) or change an Element's values (such as populating a List Element).      </p>
<p>You can use Update to do things like:    <br />
<em> Have one Element (appear to) make a change to another Element    <br />
</em> Disable a button, slider, input field, etc    <br />
<em> Change a button's text    <br />
</em> Change an Element's text or background color    <br />
<em> Add text to a scrolling output window    <br />
</em> Change the choices in a list    <br />
* etc        </p>
<p>The way this is done is via an Update method that is available for nearly all of the Elements.  Here is an example of a program that uses a persistent window that is updated.      </p>
<p><img alt="snap0272" src="https://user-images.githubusercontent.com/13696193/45260249-ec4e4000-b3af-11e8-853b-9b29d0bf7797.jpg" />      </p>
<p>In some programs these updates happen in response to another Element.  This program takes a Spinner and a Slider's input values and uses them to resize a Text Element.  The Spinner and Slider are on the left, the Text element being changed is on the right.      </p>
<pre><code># Testing async window, see if can have a slider      
# that adjusts the size of text displayed

import PySimpleGUI as sg      
fontSize = 12      
layout = [[sg.Spin([sz for sz in range(6, 172)], font=('Helvetica 20'), initial_value=fontSize, change_submits=True, key='spin'),      
           sg.Slider(range=(6,172), orientation='h', size=(10,20),      
           change_submits=True, key='slider', font=('Helvetica 20')),      
           sg.Text("Aa", size=(2, 1), font="Helvetica "  + str(fontSize), key='text')]]

sz = fontSize      
window = sg.Window("Font size selector", grab_anywhere=False).Layout(layout)      
# Event Loop      
while True:      
    event, values= window.Read()      
    if event is None:      
        break      
    sz_spin = int(values['spin'])      
    sz_slider = int(values['slider'])      
    sz = sz_spin if sz_spin != fontSize else sz_slider      
    if sz != fontSize:      
        fontSize = sz      
        font = "Helvetica "  + str(fontSize)      
        window.FindElement('text').Update(font=font)      
        window.FindElement('slider').Update(sz)      
        window.FindElement('spin').Update(sz)

print("Done.")
</code></pre>
<p>Inside the event loop we read the value of the Spinner and the Slider using those Elements' keys.    <br />
For example, <code>values['slider']</code> is the value of the Slider Element.      </p>
<p>This program changes all 3 elements if either the Slider or the Spinner changes.  This is done with these statements:      </p>
<pre><code>    window.FindElement('text').Update(font=font)      
    window.FindElement('slider').Update(sz)      
    window.FindElement('spin').Update(sz)
</code></pre>
<p>Remember this design pattern because you will use it OFTEN if you use persistent windows.      </p>
<p>It works as follows.  The call to <code>window.FindElement</code> returns the Element object represented by they provided <code>key</code>.  This element is then updated by calling it's <code>Update</code> method.  This is another example of Python's "chaining" feature. We could write this code using the long-form:      </p>
<pre><code>text_element = window.FindElement('text')      
text_element.Update(font=font)
</code></pre>
<p>The takeaway from this exercise is that keys are key in PySimpleGUI's design.  They are used to both read the values of the window and also to identify elements.  As already mentioned, they are used as targets in  Button calls.      </p>
<h3 id="locating-elements">Locating Elements</h3>
<p>The Window method call that's used to find an element is:
<code>FindElement</code>
or the shortened version
<code>Element</code></p>
<p>When you see a call to window.FindElement or window.Element, then you know an element is being addressed.  Normally this is done so you can call the element's Update method.  </p>
<h3 id="progressbar-progress-meters">ProgressBar / Progress Meters</h3>
<p>Note that to change a progress meter's progress, you call UpdateBar, not Update.      It's an old naming convention that's left over from before the Update calls were implemented.</p>
<h1 id="keyboard-mouse-capture">Keyboard &amp; Mouse Capture</h1>
<p>Beginning in version 2.10 you can capture keyboard key presses and mouse scroll-wheel events.   Keyboard keys can be used, for example, to detect the page-up and page-down keys for a PDF viewer.  To use this feature, there's a boolean setting in the Window call <code>return_keyboard_events</code> that is set to True in order to get keys returned along with buttons.      </p>
<p>Keys and scroll-wheel events are returned in exactly the same way as buttons.      </p>
<p>For scroll-wheel events, if the mouse is scrolled up, then the <code>button</code> text will be <code>MouseWheel:Up</code>.   For downward scrolling, the text returned is <code>MouseWheel:Down</code>      </p>
<p>Keyboard keys return 2 types of key events. For "normal" keys (a,b,c, etc), a single character is returned that represents that key.  Modifier and special keys are returned as a string with 2 parts:      </p>
<pre><code>Key Sym:Key Code
</code></pre>
<p>Key Sym is a string such as 'Control_L'.  The Key Code is a numeric representation of that key.  The left control key, when pressed will return the value 'Control_L:17'      </p>
<pre><code>import PySimpleGUI as sg

# Recipe for getting keys, one at a time as they are released  
# If want to use the space bar, then be sure and disable the "default focus"

with sg.Window("Keyboard Test", return_keyboard_events=True, use_default_focus=False) as window:  
    text_elem = sg.Text("", size=(18, 1))  
    layout = [[sg.Text("Press a key or scroll mouse")],  
              [text_elem],  
              [sg.Button("OK")]]

    window.Layout(layout)  
    # ---===--- Loop taking in user input --- #  
while True:  
    event, value = window.Read()

    if event == "OK"  or event is None:  
        print(event, "exiting")  
        break  
   text_elem.Update(event)
</code></pre>
<p>You want to turn off the default focus so that there no buttons that will be selected should you press the spacebar.      </p>
<h3 id="realtime-keyboard-capture">Realtime Keyboard Capture</h3>
<p>Use realtime keyboard capture by calling      </p>
<pre><code>import PySimpleGUI as sg

with sg.Window("Realtime Keyboard Test", return_keyboard_events=True, use_default_focus=False) as window:  
    layout = [[sg.Text("Hold down a key")],  
              [sg.Button("OK")]]

    window.Layout(layout)

    while True:  
        event, value = window.Read(timeout=0)  
        if event == "OK"  or event is None:  
            print(event, value, "exiting")  
            break  
        if event != sg.TIMEOUT_KEY:  
            print(event)
</code></pre>
<h1 id="menus">Menus</h1>
<h2 id="menubar">MenuBar</h2>
<p>Beginning in version 3.01 you can add a MenuBar to your window.  You specify the menus in much the same way as you do window layouts, with lists.  Menu selections are returned as events and as of 3.17, also as in the values dictionary.  The value returned will be the entire menu entry, including the key if you specified one.</p>
<p>This definition:      </p>
<pre><code>menu_def = [['File', ['Open', 'Save', 'Exit',]],      
            ['Edit', ['Paste', ['Special', 'Normal',], 'Undo'],],      
            ['Help', 'About...'],]
</code></pre>
<p>Note the placement of ',' and of [].  It's tricky to get the nested menus correct that implement cascading menus.  See how paste has Special and Normal as a list after it.  This means that Paste has a cascading menu with items Special and Normal.      </p>
<p>They menu_def layout produced this window:      </p>
<p><img alt="menu" src="https://user-images.githubusercontent.com/13696193/45306723-56b7cb00-b4eb-11e8-8cbd-faef0c90f8b4.jpg" />      </p>
<p>To add a menu to a Window place the <code>Menu</code> or <code>MenuBar</code> element into your layout.</p>
<pre><code>layout = [[sg.Menu(menu_def)]]
</code></pre>
<p>It doesn't really matter where you place the Menu Element in your layout as it will always be located at the top of the window.</p>
<h2 id="buttonmenus">ButtonMenus</h2>
<p>Button menus were introduced in version 3.21, having been previously released in PySimpleGUIQt.  They work exactly the same and are source code compatible between PySimpleGUI and PySimpleGUIQt.  These types of menus take a single menu entry where a Menu Bar takes a list of menu entries.</p>
<h2 id="right-click-menus">Right Click Menus</h2>
<p>Right Click Menus were introduced in version 3.21.  Almost every element has a right_click_menu parameter and there is a window-level setting for rich click menu that will attach a right click menu to all elements in the window.</p>
<p>The menu definition is the same a s the button menu definition, a single menu entry.</p>
<pre><code class="python">right_click_menu = ['&amp;Right', ['Right', '!&amp;Click', '&amp;Menu', 'E&amp;xit', 'Properties']]
</code></pre>

<p>The first string in a right click menu and a button menu is <strong><em>ignored</em></strong>.  It is not used.  Normally you would put the string that is shown on the menu bar in that location.</p>
<p><strong>Return values for right click menus are different than menu bars and button menus.</strong>  Instead of the value being returned through the values dictionary, it is instead sent back as an Event.  You will not</p>
<h2 id="menu-shortcut-keys">Menu Shortcut keys</h2>
<p>You have used ALT-key in other Windows programs to navigate menus.  For example Alt-F+X exits the program.  The Alt-F pulls down the File menu.  The X selects the entry marked Exit.      </p>
<p>The good news is that PySimpleGUI allows you to create the same kind of menus!  Your program can play with the big-boys.  And, it's trivial to do.      </p>
<p>All that's required is for your to add an "&amp;" in front of the letter you want to appear with an underscore.  When you hold the Alt key down you will see the menu with underlines that you marked.      </p>
<p>One other little bit of polish you can add are separators in your list.  To add a line in your list of menu choices, create a menu entry that looks like this: <code>'---'</code>      </p>
<p>This is an example Menu with underlines and a separator.      </p>
<pre><code># ------ Menu Definition ------ #      
menu_def = [['&amp;File', ['&amp;Open', '&amp;Save', '---', 'Properties', 'E&amp;xit'  ]],      
            ['&amp;Edit', ['Paste', ['Special', 'Normal',], 'Undo'],],      
            ['&amp;Help', '&amp;About...'],]      
</code></pre>

<p>And this is the spiffy menu it produced:    <br />
<img alt="menus with shortcuts" src="https://user-images.githubusercontent.com/13696193/46251674-f5b74f00-c427-11e8-95c6-547adc59041b.jpg" />      </p>
<h2 id="disabled-menu-entries">Disabled Menu Entries</h2>
<p>If you want one of your menu items to be disabled, then place a '!' in front of the menu entry.  To disable the Paste menu entry in the previous examples, the entry would be:
<code>['!&amp;Edit', ['Paste', ['Special', 'Normal',], 'Undo'],]</code></p>
<p>If your want to change the disabled menu item flag / character from '!' to something else, change the variable <code>MENU_DISABLED_CHARACTER</code></p>
<h2 id="keys-for-menus">Keys for Menus</h2>
<p>Beginning in version 3.17 you can add a <code>key</code> to your menu entries.  The <code>key</code> value will be removed prior to be inserted into the menu.  When you receive Menu events, the entire menu entry, including the <code>key</code> is returned.  A key is indicated by adding <code>::</code> after a menu entry, followed by the key.</p>
<p>To add the <code>key</code> <code>_MY_KEY_</code> to the Special menu entry, the code would be:</p>
<p><code>['&amp;Edit', ['Paste', ['Special::_MY_KEY_', 'Normal',], 'Undo'],]</code></p>
<p>If you want to change the characters that indicate a key follows from '::' to something else, change the variable <code>MENU_KEY_SEPARATOR</code>   </p>
<h1 id="running-multiple-windows">Running Multiple Windows</h1>
<p>If you wish to run multiple windows in your event loop, then there are 2 methods for doing this.  </p>
<ol>
<li>First window does not remain active while second window is visible</li>
<li>First window remains active while second window is visible</li>
</ol>
<p>You will find the 2 design matters in 2 demo programs in the Demo Program area of the GitHub (http://www.PySimpleGUI.com)</p>
<p><strong><em>Critically important</em></strong>
When creating a new window you must use a "fresh" layout every time.  You cannot reuse a layout from a previous window.  As a result you will see the layout for window 2 being defined inside of the larger event loop.</p>
<p>A rule of thumb to follow:</p>
<blockquote>
<p>If you are calling <code>Window</code> then you should define your window layout
in the statement just prior to the <code>Window</code> call.</p>
</blockquote>
<h2 id="multi-window-design-pattern-1-both-windows-active">Multi-Window Design Pattern 1 - both windows active</h2>
<pre><code class="python">import PySimpleGUI as sg  

# Design pattern 2 - First window remains active  

layout = [[ sg.Text('Window 1'),],  
          [sg.Input(do_not_clear=True)],  
          [sg.Text('', key='_OUTPUT_')],  
          [sg.Button('Launch 2'), sg.Button('Exit')]]  

win1 = sg.Window('Window 1').Layout(layout)  

win2_active = False  
while True:  
    ev1, vals1 = win1.Read(timeout=100)  
    win1.FindElement('_OUTPUT_').Update(vals1[0])  
    if ev1 is None or ev1 == 'Exit':  
        break  

     if not win2_active and ev1 == 'Launch 2':  
        win2_active = True  
        layout2 = [[sg.Text('Window 2')],  
                   [sg.Button('Exit')]]  

        win2 = sg.Window('Window 2').Layout(layout2)  

    if win2_active:  
        ev2, vals2 = win2.Read(timeout=100)  
        if ev2 is None or ev2 == 'Exit':  
            win2_active  = False  
            win2.Close()
</code></pre>

<h2 id="multi-window-design-pattern-2-only-1-active-window">Multi-Window Design Pattern 2 - only 1 active window</h2>
<pre><code class="python">import PySimpleGUIQt as sg  

# Design pattern 1 - First window does not remain active  

layout = [[ sg.Text('Window 1'),],  
          [sg.Input(do_not_clear=True)],  
          [sg.Text('', key='_OUTPUT_')],  
          [sg.Button('Launch 2')]]  

win1 = sg.Window('Window 1').Layout(layout)  
win2_active=False  
while True:  
    ev1, vals1 = win1.Read(timeout=100)  
    if ev1 is None:  
        break  
    win1.FindElement('_OUTPUT_').Update(vals1[0])  

    if ev1 == 'Launch 2'  and not win2_active:  
        win2_active = True  
        win1.Hide()  
        layout2 = [[sg.Text('Window 2')],       # note must create a layout from scratch every time. No reuse  
                   [sg.Button('Exit')]]  

        win2 = sg.Window('Window 2').Layout(layout2)  
        while True:  
            ev2, vals2 = win2.Read()  
            if ev2 is None or ev2 == 'Exit':  
                win2.Close()  
                win2_active = False  
                win1.UnHide()  
                break
</code></pre>

<h1 id="sample-applications">Sample Applications</h1>
<p>There are too many to list!!</p>
<p>There are over 130 sample programs to give you a jump start.</p>
<h2 id="packages-used-in-demos">Packages Used In Demos</h2>
<p>While the core PySimpleGUI code  does not utilize any 3rd party packages, some of the demos do.  They add a GUI to a few popular packages.  These packages include:    <br />
  * <a href="https://github.com/gunthercox/ChatterBot">Chatterbot</a>    <br />
  * <a href="https://github.com/olemb/mido">Mido</a>    <br />
  * <a href="https://matplotlib.org/">Matplotlib</a>    <br />
  * <a href="https://github.com/rk700/PyMuPDF">PyMuPDF</a>      </p>
<h1 id="creating-a-windows-exe-file">Creating a Windows .EXE File</h1>
<p>It's possible to create a single .EXE file that can be distributed to Windows users. There is no requirement to install the Python interpreter on the PC you wish to run it on. Everything it needs is in the one EXE file, assuming you're running a somewhat up to date version of Windows.      </p>
<p>Installation of the packages, you'll need to install PySimpleGUI and PyInstaller (you need to install only once)      </p>
<pre><code>pip install PySimpleGUI      
pip install PyInstaller      

</code></pre>

<p>To create your EXE file from your program that uses PySimpleGUI,  <code>my_program.py</code>, enter this command in your Windows command prompt:      </p>
<pre><code>pyinstaller -wF my_program.py      

</code></pre>

<p>You will be left with a single file,  <code>my_program.exe</code>, located in a folder named  <code>dist</code>  under the folder where you executed the  <code>pyinstaller</code>  command.      </p>
<p>That's all... Run your  <code>my_program.exe</code>  file on the Windows machine of your choosing.      </p>
<blockquote>
<p>"It's just that easy."      </p>
</blockquote>
<p>(famous last words that screw up just about anything being referenced)      </p>
<p>Your EXE file should run without creating a "shell window". Only the GUI window should show up on your taskbar.      </p>
<p>If you get a crash with something like:      </p>
<pre><code>ValueError: script '.......\src\tkinter' not found      
</code></pre>

<p>Then try adding <strong><code>--hidden-import tkinter</code></strong> to your command      </p>
<h1 id="creating-a-mac-app-file">Creating a Mac App File</h1>
<p>There are reports that PyInstaller can be used to create App files.  It's not been officially tested.</p>
<p>Run this command on your Mac</p>
<blockquote>
<p>pyinstaller --onefile --add-binary='/System/Library/Frameworks/Tk.framework/Tk':'tk' --add-binary='/System/Library/Frameworks/Tcl.framework/Tcl':'tcl' your_program.py</p>
</blockquote>
<p>This info was located on Reddit with the source traced back to:
https://github.com/pyinstaller/pyinstaller/issues/1350</p>
<h2 id="fun-stuff">Fun Stuff</h2>
<p>Here are some things to try if you're bored or want to further customize      </p>
<p><strong>Debug Output</strong>    <br />
Be sure and check out the EasyPrint (Print) function described in the high-level API section.  Leave your code the way it is, route your stdout and stderror to a scrolling window.      </p>
<p>For a fun time, add these lines to the top of your script      </p>
<pre><code>import PySimpleGUI as sg      
print = sg.Print
</code></pre>
<p>This will turn all of your print statements into prints that display in a window on your screen rather than to the terminal.      </p>
<p><strong>Look and Feel</strong>    <br />
Dial in the look and feel that you like with the <code>SetOptions</code> function.  You can change all of the defaults in one function call.  One line of code to customize the entire GUI.    <br />
Or beginning in version 2.9 you can choose from a look and feel using pre-defined color schemes.   Call ChangeLookAndFeel with a description string.      </p>
<pre><code>sg.ChangeLookAndFeel('GreenTan')
</code></pre>
<p>Valid values for the  description string are:      </p>
<pre><code>  GreenTan      
  LightGreen      
  BluePurple      
  Purple      
  BlueMono      
  GreenMono      
  BrownBlue      
  BrightColors      
  NeutralBlue      
  Kayak      
  SandyBeach      
  TealMono
</code></pre>
<p>To see the latest list of color choices, take a look at the bottom of the <code>PySimpleGUI.py</code> file where you'll find the <code>ChangLookAndFeel</code> function.      </p>
<p>You can also combine the <code>ChangeLookAndFeel</code> function with the <code>SetOptions</code> function to quickly modify one of the canned color schemes.  Maybe you like the colors but was more depth to your bezels.  You can dial in exactly what you want.      </p>
<p><strong>ObjToString</strong>    <br />
Ever wanted to easily display an objects contents easily?  Use ObjToString to get a nicely formatted recursive walk of your objects.    <br />
This statement:      </p>
<pre><code>print(sg.ObjToSting(x))
</code></pre>
<p>And this was the output      </p>
<pre><code>&lt;class '__main__.X'&gt;      
    abc = abc      
    attr12 = 12      
    c = &lt;class '__main__.C'&gt;      
        b = &lt;class '__main__.B'&gt;      
            a = &lt;class '__main__.A'&gt;      
                attr1 = 1      
                attr2 = 2      
                attr3 = three      
            attr10 = 10      
            attrx = x
</code></pre>
<p>You'll quickly wonder how you ever coded without it.      </p>
<hr />
<h1 id="known-issues">Known Issues</h1>
<p>While not an "issue" this is a <strong><em>stern warning</em></strong>      </p>
<h2 id="do-not-attempt-to-call-pysimplegui-from-multiple-threads-its-tkinter-based-and-tkinter-has-issues-with-multiple-threads"><strong>Do not attempt</strong> to call <code>PySimpleGUI</code> from multiple threads! It's <code>tkinter</code> based and <code>tkinter</code> has issues with multiple threads</h2>
<p><strong>Progress Meters</strong> - the visual graphic portion of the meter may be off.  May return to the native tkinter progress meter solution in the future.  Right now a "custom" progress meter is used.  On the bright side, the statistics shown are extremely accurate and can tell you something about the performance of your code.    If you are running 2 or more progress meters at the same time using <code>OneLineProgressMeter</code>, you need to close the meter by using the "Cancel" button rather than the X      </p>
<p><strong>Async windows</strong> - these include the 'easy' windows (<code>OneLineProgressMeter</code> and EasyPrint/Print). If you start overlapping having Async windows open with normal windows then things get a littler squirrelly.  Still tracking down the issues and am making it more solid every day possible.  You'll know there's an issue when you see blank window.      </p>
<p><strong>EasyPrint</strong> - EasyPrint is a new feature that's pretty awesome.  You print and the output goes to a window, with a scroll bar, that you can copy and paste from.  Being a new feature, it's got some potential problems.  There are known interaction problems with other GUI windows.  For example, closing a Print window can also close other windows you have open.  For now, don't close your debug print window until other windows are closed too.      </p>
<h2 id="contributing">Contributing</h2>
<p>A MikeTheWatchGuy production... entirely responsible for this code.... unless it causes you trouble in which case I'm not at all responsible.      </p>
<h2 id="versions">Versions</h2>
<table>
<thead>
<tr>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0.9</td>
<td>July 10, 2018 - Initial Release</td>
</tr>
<tr>
<td>1.0.21</td>
<td>July 13, 2018 - Readme updates</td>
</tr>
<tr>
<td>2.0.0</td>
<td>July 16, 2018 - ALL optional parameters renamed from CamelCase to all_lower_case</td>
</tr>
<tr>
<td>2.1.1</td>
<td>July 18, 2018 - Global settings exposed, fixes</td>
</tr>
<tr>
<td>2.2.0</td>
<td>July 20, 2018 - Image Elements, Print output</td>
</tr>
<tr>
<td>2.3.0</td>
<td>July 23, 2018 - Changed form.Read return codes, Slider Elements, Listbox element. Renamed some methods but left legacy calls in place for now.</td>
</tr>
<tr>
<td>2.4.0</td>
<td>July 24, 2018 - Button images. Fixes so can run on Raspberry Pi</td>
</tr>
<tr>
<td>2.5.0</td>
<td>July 26, 2018 - Colors. Listbox scrollbar. tkinter Progress Bar instead of homegrown.</td>
</tr>
<tr>
<td>2.6.0</td>
<td>July 27, 2018 - auto_size_button setting.  License changed to LGPL 3+</td>
</tr>
<tr>
<td>2.7.0</td>
<td>July 30, 2018 - realtime buttons, window_location default setting</td>
</tr>
<tr>
<td>2.8.0</td>
<td>Aug 9, 2018 - New None default option for Checkbox element, text color option for all elements, return values as a dictionary, setting focus, binding return key</td>
</tr>
<tr>
<td>2.9.0</td>
<td>Aug 16,2018 - Screen flash fix, <code>do_not_clear</code> input field option, <code>autosize_text</code> defaults to <code>True</code> now, return values as ordered dict, removed text target from progress bar, rework of return values and initial return values, removed legacy Form.Refresh() method (replaced by Form.ReadNonBlockingForm()), COLUMN elements!!, colored text defaults</td>
</tr>
<tr>
<td>2.10.0</td>
<td>Aug 25, 2018 - Keyboard &amp; Mouse features (Return individual keys as if buttons, return mouse scroll-wheel as button, bind return-key to button, control over keyboard focus), SaveAs Button, Update &amp; Get methods for InputText, Update for Listbox, Update &amp; Get for Checkbox, Get for Multiline, Color options for Text Element Update, Progess bar Update can change max value, Update for Button to change text &amp; colors, Update for Image Element, Update for Slider, Form level text justification, Turn off default focus, scroll bar for Listboxes, Images can be from filename or from in-RAM, Update for Image).  Fixes - text wrapping in buttons, msg box, removed slider borders entirely and others</td>
</tr>
<tr>
<td>2.11.0</td>
<td>Aug 29, 2018 - Lots of little changes that are needed for the demo programs to work. Buttons have their own default element size, fix for Mac default button color, padding support for all elements, option to immediately return if list box gets selected, FilesBrowse button, Canvas Element, Frame Element, Slider resolution option, Form.Refresh method, better text wrapping, 'SystemDefault' look and feel settin</td>
</tr>
<tr>
<td>2.20.0</td>
<td>Sept 4, 2018 - Some sizable features this time around of interest to advanced users.  Renaming of the MsgBox functions to Popup. Renaming GetFile, etc, to PopupGetFile. High-level windowing capabilities start with Popup, PopupNoWait/PopupNonblocking, PopupNoButtons, default icon, change_submits option for Listbox/Combobox/Slider/Spin/, New OptionMenu element, updating elements after shown, system defaul color option for progress bars, new button type (Dummy Button) that only closes a window, SCROLLABLE Columns!! (yea, playing in the Big League now), LayoutAndShow function removed, form.Fill - bulk updates to forms, FindElement - find element based on key value (ALL elements have keys now), no longer use grid packing for row elements (a potentially huge change), scrolled text box sizing changed, new look and feel themes (Dark, Dark2, Black, Tan, TanBlue, DarkTanBlue, DarkAmber, DarkBlue, Reds, Green)</td>
</tr>
<tr>
<td>2.30.0</td>
<td>Sept 6, 2018 - Calendar Chooser (button), borderless windows, load/save form to disk</td>
</tr>
<tr>
<td>3.0.0</td>
<td>Sept 7, 2018 - The "fix for poor choice of 2.x numbers" release. Color Chooser (button), "grab anywhere" windows are on by default, disable combo boxes, Input Element text justification (last part needed for 'tables'), Image Element changes to support OpenCV?, PopupGetFile and PopupGetFolder have better no_window option</td>
</tr>
<tr>
<td>3.01.01</td>
<td>Sept 10, 2018 - Menus! (sort of a big deal)</td>
</tr>
<tr>
<td>3.01.02</td>
<td>Step 11, 2018 - All Element.Update functions have a <code>disabled</code> parameter so they can be disabled.  Renamed some parameters in Update function (sorry if I broke your code), fix for bug in Image.Update. Wasn't setting size correctly, changed grab_anywhere logic again,added grab anywhere option to PupupGetText (assumes disabled)</td>
</tr>
<tr>
<td>3.02.00</td>
<td>Sept 14, 2018 - New Table Element (Beta release), MsgBox removed entirely, font setting for InputText Element, <strong>packing change</strong> risky change that allows some Elements to be resized,removed command parameter from Menu Element, new function names for ReadNonBlocking (Finalize, PreRead), change to text element autosizing and wrapping (yet again), lots of parameter additions to Popup functions (colors, etc).</td>
</tr>
<tr>
<td>3.03.00</td>
<td>New feature - One Line Progress Meters, new display_row_numbers for Table Element, fixed bug in EasyProgresssMeters (function will soon go away), OneLine and Easy progress meters set to grab anywhere but can be turned off.</td>
</tr>
<tr>
<td>03,04.00</td>
<td>Sept 18, 2018 - New features - Graph Element, Frame Element, more settings exposed to Popup calls.  See notes below for more.</td>
</tr>
<tr>
<td>03.04.01</td>
<td>Sept 18, 2018 - See release notes</td>
</tr>
<tr>
<td>03.05.00</td>
<td>Sept 20, 2018 - See release notes</td>
</tr>
<tr>
<td>03.05.01</td>
<td>Sept 22, 2018 - See release notes</td>
</tr>
<tr>
<td>03.05.02</td>
<td>Sept 23, 2018 - See release notes</td>
</tr>
<tr>
<td>03.06.00</td>
<td>Sept 23, 2018 - Goodbye FlexForm, hello Window</td>
</tr>
<tr>
<td>03.08.00</td>
<td>Sept 25, 2018 - Tab and TabGroup Elements\</td>
</tr>
<tr>
<td>01.00.00 for 2.7</td>
<td>Sept 25, 2018 - First release for 2.7</td>
</tr>
<tr>
<td>03.08.04</td>
<td>Sept 30, 2018 - See release notes</td>
</tr>
<tr>
<td>03.09.00</td>
<td>Oct 1, 2018</td>
</tr>
<tr>
<td>2.7 01.01.00</td>
<td>Oct 1, 2018</td>
</tr>
<tr>
<td>2.7 01.01.02</td>
<td>Oct 8, 2018</td>
</tr>
<tr>
<td>03.09.01</td>
<td>Oct 8, 2018</td>
</tr>
<tr>
<td>3.9.3 &amp; 1.1.3</td>
<td>Oct 11, 2018</td>
</tr>
<tr>
<td>3.9.4 &amp; 1.1.4</td>
<td>Oct 16, 2018</td>
</tr>
<tr>
<td>3.10.1 &amp; 1.2.1</td>
<td>Oct 20, 2018</td>
</tr>
<tr>
<td>3.10.3 &amp; 1.2.3</td>
<td>Oct 23, 2018</td>
</tr>
<tr>
<td>3.11.0 &amp; 1.11.0</td>
<td>Oct 28, 2018</td>
</tr>
<tr>
<td>3.12.0 &amp; 1.12.0</td>
<td>Oct 28, 2018</td>
</tr>
<tr>
<td>3.13.0 &amp; 1.13.0</td>
<td>Oct 29, 2018</td>
</tr>
<tr>
<td>3.14.0 &amp; 1.14.0</td>
<td>Nov 2, 2018</td>
</tr>
<tr>
<td>3.15.0 &amp; 1.15.0</td>
<td>Nov 20, 2018</td>
</tr>
<tr>
<td>3.16.0 &amp; 1.16.0</td>
<td>Nov 26, 2018</td>
</tr>
<tr>
<td>3.17.0 &amp; 1.17.0</td>
<td>Dec 1, 2018</td>
</tr>
</tbody>
</table>
<h2 id="release-notes">Release Notes</h2>
<p>2.3 - Sliders, Listbox's and Image elements (oh my!)      </p>
<p>If using Progress Meters, avoid cancelling them when you have another window open.  It could lead to future windows being blank. It's being worked on.      </p>
<p>New debug printing capability.  <code>sg.Print</code>      </p>
<p>2.5 Discovered issue with scroll bar on <code>Output</code> elements.  The bar will match size of ROW not the size of the element.  Normally you never notice this due to where on a form the <code>Output</code> element goes.      </p>
<p>Listboxes are still without scrollwheels. The mouse can drag to see more items.  The mouse scrollwheel will also scroll the list and will <code>page up</code> and <code>page down</code> keys.      </p>
<p>2.7 Is the "feature complete" release. Pretty much all features are done and in the code      </p>
<p>2.8 More text color controls.  The caller has more control over things like the focus and what buttons should be clicked when enter key is pressed. Return values as a dictionary! (NICE addition)      </p>
<p>2.9 COLUMNS!  This is the biggest feature and had the biggest impact on the code base.  It was a difficult feature to add, but it was worth it.  Can now make even more layouts. Almost any layout is possible with this addition.      </p>
<p>.................. insert releases 2.9 to 2.30 .................      </p>
<p>3.0 We've come a long way baby!  Time for a major revision bump.  One reason is that the numbers started to confuse people  the latest release was 2.30, but some people read it as 2.3 and thought it went backwards.  I kinda messed up the 2.x series of numbers, so why not start with a clean slate.  A lot has happened anyway so it's well earned.      </p>
<p>One change that will set PySimpleGUI apart is the parlor trick of being able to move the window by clicking on it anywhere.  This is turned on by default.  It's not a common way to interact with windows.  Normally you have to move using the titlebar.  Not so with PySimpleGUI.  Now you can drag using any part of the window.  You will want to turn off for windows with sliders.  This feature is enabled in the Window call.      </p>
<p>Related to the Grab Anywhere feature is the no_titlebar option, again found in the call to Window.  Your window will be a spiffy, borderless window.  It's a really interesting effect.  Slight problem is that you do not have an icon on the taskbar with these types of windows, so if you don't supply a button to close the window, there's no way to close it other than task manager.      </p>
<p>3.0.2 Still making changes to Update methods with many more ahead in the future.  Continue to mess with grab anywhere option.  Needed to disable in more places such as the PopupGetText function.  Any time these is text input on a form, you generally want to turn off the grab anywhere feature.      </p>
<h4 id="320">3.2.0</h4>
<p>Biggest change was the addition of the Table Element.  Trying to make changes so that form resizing is a possibility but unknown if will work in the long run.  Removed all MsgBox, Get* functions and replaced with Popup functions.  Popups had multiple new parameters added to change the look and feel of a popup.      </p>
<h4 id="330">3.3.0</h4>
<p>OneLineProgressMeter function added which gives you not only a one-line solution to progress meters, but it also gives you the ability to have more than 1 running at the same time, something not possible with the EasyProgressMeterCall      </p>
<h4 id="340">3.4.0</h4>
<ul>
<li>Frame - New Element - a labelled frame for grouping elements. Similar    <br />
   to Column      </li>
<li>Graph (like a Canvas element except uses the caller's    <br />
   coordinate system rather than tkinter's).      </li>
<li>initial_folder - sets starting folder for browsing type buttons (browse for file/folder).      </li>
<li>Buttons return  key value rather than button text <strong>If</strong> a <code>key</code> is specified,      </li>
<li>OneLineProgressMeter!  Replaced EasyProgressMeter (sorry folks that's    <br />
   the way progress works sometimes)      </li>
<li>Popup - changed ALL of the Popup calls to   provide many more customization settings      <ul>
<li>Popup      </li>
<li>PopupGetFolder      </li>
<li>PopupGetFile      </li>
<li>PopupGetText      </li>
<li>Popup      </li>
<li>PopupNoButtons      </li>
<li>PopupNonBlocking      </li>
<li>PopupNoTitlebar      </li>
<li>PopupAutoClose      </li>
<li>PopupCancel      </li>
<li>PopupOK      </li>
<li>PopupOKCancel      </li>
<li>PopupYesNo      </li>
</ul>
</li>
</ul>
<h4 id="341">3.4.1</h4>
<ul>
<li>Button.GetText - Button class method.  Returns the current text being shown on a button.      </li>
<li>Menu - Tearoff option. Determines if menus should allow them to be torn off      </li>
<li>Help - Shorcut button. Like Submit, cancel, etc      </li>
<li>ReadButton - shortcut for ReadFormButton      </li>
</ul>
<h4 id="350">3.5.0</h4>
<ul>
<li>Tool Tips for all elements      </li>
<li>Clickable text      </li>
<li>Text Element relief setting      </li>
<li>Keys as targets for buttons      </li>
<li>New names for buttons:      </li>
<li>Button = SimpleButton      </li>
<li>RButton = ReadButton = ReadFormButton      </li>
<li>Double clickable list entries      </li>
<li>Auto sizing table widths works now      </li>
<li>Feature DELETED - Scaling. Removed from all elements      </li>
</ul>
<h4 id="351">3.5.1</h4>
<ul>
<li>Bug fix for broken PySimpleGUI if Python version &lt; 3.6 (sorry!)      </li>
<li>LOTS of Readme changes      </li>
</ul>
<h4 id="352">3.5.2</h4>
<ul>
<li>Made <code>Finalize()</code> in a way that it can be chained      </li>
<li>Fixed bug in return values from Frame Element contents      </li>
</ul>
<h4 id="360">3.6.0</h4>
<ul>
<li>Renamed FlexForm to Window      </li>
<li>Removed LookAndFeel capability from Mac platform.      </li>
</ul>
<h4 id="380">3.8.0</h4>
<ul>
<li>Tab and TabGroup Elements - awesome new capabilities      </li>
</ul>
<h4 id="100-python-27">1.0.0 Python 2.7</h4>
<p>It's official.  There is a 2.7 version of PySimpleGUI!      </p>
<h4 id="382">3.8.2</h4>
<ul>
<li>Exposed <code>TKOut</code> in Output Element      </li>
<li><code>DrawText</code> added to Graph Elements      </li>
<li>Removed <code>Window.UpdateElements</code>      </li>
<li><code>Window.grab_anywere</code> defaults to False      </li>
</ul>
<h4 id="383">3.8.3</h4>
<ul>
<li>Listbox, Slider, Combobox, Checkbox,  Spin, Tab Group - if change_submits is set, will return the Element's key rather than ''      </li>
<li>Added change_submits capability to Checkbox, Tab Group      </li>
<li>Combobox - Can set value to an Index into the Values table rather than the Value itself      </li>
<li>Warnings added to Drawing routines for Graph element (rather than crashing)      </li>
<li>Window - can "force top level" window to be used rather than a normal window.  Means that instead of calling Tk to get a window, will call TopLevel to get the window      </li>
<li>Window Disable / Enable - Disables events (button clicks, etc) for a Window.  Use this when you open a second window and want to disable the first window from doing anything. This will simulate a 'dialog box'      </li>
<li>Tab Group returns a value with Window is Read.  Return value is the string of the selected tab      </li>
<li>Turned off grab_anywhere for Popups      </li>
<li>New parameter, default_extension, for PopupGetFile      </li>
<li>Keyboard shortcuts for menu items. Can hold ALT key to select items in men      </li>
<li>Removed old-style Tabs - Risky change because it hit fundamental window packing and creation. Will also break any old code using this style tab (sorry folks this is how progress happens)      </li>
</ul>
<h4 id="386">3.8.6</h4>
<ul>
<li>Fix for Menus.      </li>
<li>Fixed table colors. Now they work      </li>
<li>Fixed returning keys for tabs      </li>
<li>Window Hide / UnHide methods      </li>
<li>Changed all Popups to remove context manager      </li>
<li>Error checking for Graphing objects and for Element Updates      </li>
</ul>
<h3 id="390-110">3.9.0 &amp; 1.1.0</h3>
<ul>
<li>The FIRST UNIFIED version of the code!    </li>
<li>Python 2.7 got a TON of features . Look back to 1.0 release for the list    </li>
<li>Tab locations - Can place Tabs on top, bottom, left, right now instead of only the top    </li>
</ul>
<h3 id="391-112">3.9.1 &amp; 1.1.2</h3>
<ul>
<li>Tab features    </li>
<li>Themes    </li>
<li>Enable / Disable    </li>
<li>Tab text colors    </li>
<li>Selected tab color    </li>
<li>New GetListValues method for Listbox    </li>
<li>Can now have multiple progress bars in 1 window    </li>
<li>Fix for closing debug-output window with other windows open    </li>
<li>Topanga Look and Feel setting    </li>
<li>User can create new look and feel settings / can access the look and feel table    </li>
<li>New PopupQuick call. Shows a non-blocking popup window with auto-close    </li>
<li>Tree Element partially done (don't use despite it showing up)    </li>
</ul>
<h3 id="393-113">3.9.3 &amp; 1.1.3</h3>
<ul>
<li>Disabled setting when creating element for:    </li>
<li>Input    </li>
<li>Combo    </li>
<li>Option Menu    </li>
<li>Listbox    </li>
<li>Radio    </li>
<li>Checkbox    </li>
<li>Spinner    </li>
<li>Multiline    </li>
<li>Buttons    </li>
<li>Slider    </li>
<li>Doc strings on all Elements updated    </li>
<li>Buttons can take image data as well as image files    </li>
<li>Button Update can change images    </li>
<li>Images can have background color    </li>
<li>Table element new num_rows parameter    </li>
<li>Table Element new alternating_row_color parameter    </li>
<li>Tree Element    </li>
<li>Window Disappear / Reappear methods    </li>
<li>Popup buttons resized to same size    </li>
<li>Exposed look and feel table    </li>
</ul>
<h3 id="394-114">3.9.4 &amp; 1.1.4</h3>
<ul>
<li>Parameter order change for Button.Update so that new button ext is at front</li>
<li>New Graph.DrawArc method</li>
<li>Slider tick interval parameter for labeling sliders</li>
<li>Menu tearoff now disabled by default</li>
<li>Tree Data printing simplified and made prettier</li>
<li>Window resizable parameter.  Defaults to not resizable</li>
<li>Button images can have text over them now</li>
<li>BUG fix in listbox double-click.  First bug fix in months</li>
<li>New Look And Feel capability.  List predefined settings using ListOfLookAndFeelValues</li>
</ul>
<h3 id="3101-121">3.10.1 &amp; 1.2.1</h3>
<ul>
<li>Combobox new readonly parameter in init and Update</li>
<li>Better default sizes for Slider</li>
<li>Read of Tables now returns which rows are selected (big damned deal feature)</li>
<li>PARTIAL support of Table.Update with new values (use at your own peril)</li>
<li>Alpha channel setting for Windows</li>
<li>Timeout setting for Window.Read (big damned deal feature)</li>
<li>Icon can be base64 image now in SetIcon call</li>
<li>Window.FindElementWithFocus call</li>
<li>Window.Move allows moving window anywhere on screen</li>
<li>Window.Minimize will minimize to taskbar</li>
<li>Button background color can be set to system default (i.e. not changed)</li>
</ul>
<h3 id="3102-122">3.10.2 &amp; 1.2.2</h3>
<p>Emergency patch release... going out same day as previous release
<em> The timeout timer for the new Read with timer wasn't being properly shut down
</em> The Image.Update method appears to not have been written correctly.  It didn't handle base64 images like the other elements that deal with images (buttons)</p>
<h3 id="3103-123">3.10.3 &amp; 1.2.3</h3>
<ul>
<li>New element - Vertical Separator</li>
<li>New parameter for InputText - change_submits. If True will cause Read to return when a button fills in the InputText element</li>
<li>Read with timeout = 0 is same as read non blocking and is the new preferred method</li>
<li>Will return event == None if window closed</li>
<li>New Close method will close all window types</li>
<li>Scrollbars for Tables automatically added (no need for a Column Element)</li>
<li>Table Update method complete</li>
<li>Turned off expand when packing row frame... was accidentally turned on (primary reason for this release)</li>
<li>Try added to Image Update so won't crash if bad image passed in</li>
</ul>
<h3 id="3110-1110">3.11.0 &amp; 1.11.0</h3>
<ul>
<li>Syncing up the second digit of the releases so that they stay in sync better.  the 2.7 release is built literally from the 3.x code so they really are the same</li>
<li>Reworked Read call... significantly.</li>
<li>Realtime buttons work with timeouts or blocking read</li>
<li>Removed default value parm on Buttons and Button Updates</li>
<li>New Tree Element parm show_expanded. Causes Tree to be shown as fully expanded</li>
<li>Tree Element now returns which rows are selected when Read</li>
<li>New Window method BringToFront</li>
<li>Shortcut buttons no longer close windows!</li>
<li>Added CloseButton, CButton that closes the windows</li>
</ul>
<h3 id="3120-1120">3.12.0 &amp; 1.12.0</h3>
<ul>
<li>Changed Button to be the same as ReadButton which means it will no longer close the window</li>
<li>All shortcut buttons no longer close the window</li>
<li>Updating a table clears selected rows information in return values</li>
<li>Progress meter uses new CloseButton</li>
<li>Popups use new CloseButton</li>
</ul>
<h3 id="3130-1130">3.13.0 &amp; 1.13.0</h3>
<ul>
<li>Improved multiple window handling of Popups when the X is used to close</li>
<li>Change submits added for:</li>
<li>Multiline</li>
<li>Input Text</li>
<li>Table</li>
<li>Tree</li>
<li>Option to close calendar chooser when date selected</li>
<li>Update for Tree Element</li>
<li>Scroll bars for Trees</li>
</ul>
<h3 id="3140-1140">3.14.0 &amp; 1.14.0</h3>
<ul>
<li>More windowing changes... <ul>
<li>using a hidden root windowing (Tk())</li>
<li>all children are Toplevel() windows</li>
</ul>
</li>
<li>Read only setting for:<ul>
<li>Input Text</li>
<li>Multiline</li>
</ul>
</li>
<li>Font setting for InputCombo, Multiline</li>
<li>change_submits setting for Radio Element</li>
<li>SetFocus for multiline, input elements</li>
<li>Default mon, day, year for calendar chooser button</li>
<li>Tree element update, added ability to change a single key</li>
<li>Message parm removed from ReadNonBlocking</li>
<li>Fix for closing windows using X</li>
<li>CurrentLocation method for Windows</li>
<li>Debug Window options<ul>
<li>location</li>
<li>font</li>
<li>no_button</li>
<li>no_titlebar</li>
<li>grab_anywhere</li>
<li>keep_on_top</li>
</ul>
</li>
<li>New Print / EasyPrint options<ul>
<li>location</li>
<li>font</li>
<li>no_button</li>
<li>no_titlebar</li>
<li>grab_anywhere</li>
<li>keep_on_top</li>
</ul>
</li>
<li>New popup, PopupQuickMessage</li>
<li>PopupGetFolder, PopupGetFile new initial_folder parm</li>
</ul>
<h3 id="3150-1150">3.15.0 &amp; 1.15.0</h3>
<ul>
<li>Error checking for InputText.Get method</li>
<li>Text color, background color added to multiline element.Update</li>
<li>Update method for Output Element - gives ability to clear the output</li>
<li>Graph Element - Read returns values if new flages set<ul>
<li>Change submits, drag submits</li>
<li>Returns x,y coordinates</li>
</ul>
</li>
<li>Column element new parm vertical_scroll_only</li>
<li>Table element new parm - bind return key - returns if return or double click</li>
<li>New Window parms - size, disable_close</li>
<li>"Better" multiwindow capabilities</li>
<li>Window.Size property</li>
<li>Popups - new title parm, custom_text<ul>
<li>title sets the window title</li>
<li>custom_text - single string or tuple string sets text on button(s)</li>
</ul>
</li>
</ul>
<h3 id="3160-1160">3.16.0 &amp; 1.16.0</h3>
<ul>
<li>Bug fix in PopupScrolled</li>
<li>New <code>Element</code> shortcut function for <code>FindElement</code></li>
<li>Dummy Stretch Element made for backwards compatibility with Qt</li>
<li>Timer function prints in milliseconds now, was seconds</li>
</ul>
<h3 id="3170-1170-2-dec-2018">3.17.0 &amp;1.17.0 2-Dec-2018</h3>
<p>3.17.0 2-Dec-2017
<em> Tooltip offset now programmable.  Set variable DEFAULT_TOOLTIP_OFFSET.  Defaults to (20,-20)
</em> Tooltips are always on top now
<em> Disable menu items
</em> Menu items can have keys
<em> StatusBar Element (preparing for a real status bar in Qt)
</em> enable_events parameter added to ALL Elements capable of generating events
<em> InputText.Update select parameter will select the input text
</em> Listbox.Update - set_to_index parameter will select a single items
<em> Menus can be updated!
</em> Menus have an entry in the return values
<em> LayoutAndRead depricated
</em> Multi-window support continues (X detection)
<em> PopupScrolled now has a location parameter
</em> row_height parameter to Table Element
<em> Stretch Element (DUMMY) so that can be source code compatible with Qt
</em> ButtonMenu Element (DUMMY) so can be source code compat with Qt.  Will implement eventually</p>
<h2 id="3180-11-dec-2018">3.18.0  11-Dec-2018</h2>
<p>NOTE - <strong>Menus are broken</strong> on version 2.7.  Don't know how long they've been this way.  Please get off legacy Python if that's what you're running.</p>
<ul>
<li>Default progress bar length changed to shorter</li>
<li>Master window and tracking of num open windows moved from global to Window class variable</li>
<li>Element visibility setting (when created and when Updating element)</li>
<li>Input text visiblity</li>
<li>Combo visiblity</li>
<li>Combo replaces InputCombo as the primary class name</li>
<li>Option menu visibility</li>
<li>Listbox visiblity</li>
<li>Listbox new SetFocus method</li>
<li>Radio visibility</li>
<li>Checkbox visibility</li>
<li>Spin visiblity</li>
<li>Spin new Get method returns current value</li>
<li>Multiline visiblity</li>
<li>Text visibility</li>
<li>StatusBar visiblity</li>
<li>Output visibility</li>
<li>Button visibility</li>
<li>Button SetFocus</li>
<li>ProgressBar - New Update method (used only for visibility)</li>
<li>Image - clickable images!  enable_events parameter</li>
<li>Image visibility</li>
<li>Canvas visibility</li>
<li>Graph visibility</li>
<li>Graph - new DrawImage capability (finally)</li>
<li>Frame visibility</li>
<li>Tab visibility (may not be fully functional)</li>
<li>TabGroup visibility</li>
<li>Slider visibility</li>
<li>Slider - new disable_number_display parameter</li>
<li>Column visibilty</li>
<li>Menu visibility - Not functional</li>
<li>Table visibility</li>
<li>Table - new num_rows parm for Update - changes number of visible rows</li>
<li>Tree visiblity</li>
<li>Window - New element_padding parameter will get padding for entire window</li>
<li>OneLineProgressMeter - Completely REPLACED the implementation</li>
<li>OneLineProgressMeter - can get reason for the cancellation (cancel button versus X)</li>
<li>EasyProgressMeter - completely removed. Use OneLineProgressMeter instead</li>
<li>Debug window, EasyPrint, Print - debug window will re-open if printed to after being closed</li>
<li>SetOptions - can change the error button color</li>
<li>Much bigger window created when running PySimpleGUI.py by itself.  Meant to help with regression testing</li>
</ul>
<h2 id="3192-13-dec-2018">3.19.2  13-Dec-2018</h2>
<ul>
<li>Warning for Mac's when trying to change button color</li>
<li>New parms for Button.Update - image_size and image_subsample</li>
<li>Buttons - remove highlight when border depth == 0</li>
<li>OneLineProgressMeter - better layout implementation</li>
</ul>
<h2 id="3200-1200-18-dec-2018">3.20.0 &amp; 1.20.0 18-Dec-2018</h2>
<ul>
<li>New Pane Element</li>
<li>Graph.DeleteFigure method</li>
<li>disable_minimize - New parameter for Window</li>
<li>Fix for 2.7 menus</li>
<li>Debug Window no longer re-routes stdout by default</li>
<li>Can re-route by specifying in Print / EasyPrint call</li>
<li>New non-blocking for PopupScrolled</li>
<li>Can set title for PopupScrolled window</li>
</ul>
<h2 id="3210-1210-28-dec-2018">3.21.0 &amp; 1.21.0 28-Dec-2018</h2>
<ul>
<li>ButtonMenu Element</li>
<li>Embedded base64 default icon</li>
<li>Input Text Right click menu</li>
<li>Disabled Input Text are now 'readonly' instead of disabled</li>
<li>Listbox right click menu</li>
<li>Multiline right click menu</li>
<li>Text right click menu</li>
<li>Output right click menu</li>
<li>Image right click menu</li>
<li>Canvas right click menu</li>
<li>Graph right click menu</li>
<li>Frame right click menu</li>
<li>Tab, tabgroup right click menu (unsure if works correctly)</li>
<li>Column right click menu</li>
<li>Table right click menu</li>
<li>Tree right click menu</li>
<li>Window level right click menu</li>
<li>Window icon can be filename or bytes (Base64 string)</li>
<li>Window.Maximize method</li>
<li>Attempted to use Styles better with Combobox</li>
<li>Fixed bug blocking setting bar colors in OneLineProgressMeter</li>
</ul>
<h1 id="3220-pysimplegui-1220-pysimplegui27">3.22.0 PySimpleGUI / 1.22.0 PySimpleGUI27</h1>
<ul>
<li>Added type hints to some portions of the code</li>
<li>Output element can be made invisible</li>
<li>Image sizing and subsample for Button images</li>
<li>Invisibility for ButtonMenusup</li>
<li>Attempt at specifying size of Column elements (limited success)</li>
<li>Table Element</li>
<li>New row_colors parameter</li>
<li>New vertical_scroll_only parameter - NOTE - will have to disable to get horizontal scrollbars</li>
<li>Tree Element</li>
<li>New row_height parameter</li>
<li>New feature - Icons for tree entries using filename or Base64 images</li>
<li>Fix for bug sending back continuous mouse events</li>
<li>New parameter silence_on_error for FindElement / Element calls</li>
<li>Slider returns float now</li>
<li>Fix for Menus when using Python 2.7</li>
<li>Combobox Styling (again)</li>
</ul>
<h1 id="3230-pysimplegui-1230-pysimplegui27-16-jan-2019">3.23.0 PySimpleGUI /  1.23.0 PySimpleGUI27 16-Jan-2019</h1>
<ul>
<li>Animated GIFs!</li>
<li>Calendar Chooser stays on top of other windows</li>
<li>Fixed bug of no column headings for Tables</li>
<li>Tables now use the font parameter</li>
</ul>
<h1 id="3240-1240-16-jan-2019">3.24.0 1.24.0 16-Jan-2019</h1>
<ul>
<li>PopupAnimated - A popup call for showing "loading" type of windows</li>
</ul>
<h1 id="325-125-20-feb-2019">3.25 &amp; 1.25 20-Feb-2019</h1>
<ul>
<li>Comments :-)</li>
<li>Convert Text to string right away</li>
<li>Caught exceptions when main program shut down with X</li>
<li>Caught exceptions in all of the graphics primitives</li>
<li>Added parameter exportselection=False to Listbox so can use multiple listboxes</li>
<li>OneLineProgressMeter - Can now change the text on every call if desired</li>
</ul>
<h3 id="upcoming">Upcoming</h3>
<p>Make suggestions people!  Future release features      </p>
<p>Port to other graphic engines.  Hook up the front-end interface to a backend other than tkinter.  Qt, WxPython, etc.  At the moment, Wx and Kivy are being considered for the next GUI framework.  Work has already begun on Wx.  Kivy is likely to be next instead of Wx however.</p>
<h2 id="code-condition">Code Condition</h2>
<pre><code>Make it run      
Make it right      
Make it fast
</code></pre>
<p>It's a recipe for success if done right.  PySimpleGUI has completed the "Make it run" phase.  It's far from "right" in many ways.  These are being worked on.  The module is particularly poor for PEP 8 compliance.  It was a learning exercise that turned into a somewhat complete GUI solution for lightweight problems.      </p>
<p>While the internals to PySimpleGUI are a tad sketchy, the public interfaces into the SDK are more strictly defined and comply with PEP 8 for the most part.      </p>
<p>Please log bugs and suggestions in the GitHub!  It will only make the code stronger and better in the end, a good thing for us all, right?      </p>
<h2 id="design">Design</h2>
<p>A moment about the design-spirit of <code>PySimpleGUI</code>.  From the beginning, this package was meant to take advantage of Python's capabilities with the goal of programming ease.      </p>
<p><strong>Single File</strong>    <br />
While not the best programming practice, the implementation resulted in a single file solution.  Only one file is needed, PySimpleGUI.py.  You can post this file, email it, and easily import it using one statement.      </p>
<p><strong>Functions as objects</strong>    <br />
In Python, functions behave just like object. When you're placing a Text Element into your form, you may be sometimes calling a function and other times declaring an object.  If you use the word Text, then you're getting an object.  If you're using <code>Txt</code>, then you're calling a function that returns a <code>Text</code> object.      </p>
<p><strong>Lists</strong>    <br />
It seemed quite natural to use Python's powerful list constructs when possible.  The form is specified as a series of lists.  Each "row" of the GUI is represented as a list of Elements. When the form read returns the results to the user, all of the results are presented as a single list.  This makes reading a form's values super-simple to do in a single line of Python code.      </p>
<p><strong>Dictionaries</strong>    <br />
Want to view your form's results as a dictionary instead of a list... no problem, just use the <code>key</code> keyword on your elements.  For complex forms with a lot of values that need to be changed frequently, this is by far the best way of consuming the results.      </p>
<p>You can also look up elements using their keys.  This is an excellent way to update elements in reaction to another element.  Call <code>form.FindElement(key)</code> to get the Element.      </p>
<p><strong>Named / Optional Parameters</strong>  <br />
This is a language feature that is featured <strong>heavily</strong>  in all of the API calls, both functions and classes.  Elements are configured, in-place, by setting one or more optional parameters.  For example, a Text element's color is chosen by setting the optional <code>text_color</code> parameter.    </p>
<p><strong>tkinter</strong>
tkinter is the "official" GUI that Python supports.  It runs on Windows, Linux, and Mac.  It was chosen as the first target GUI framework due to its <strong><em>ubiquity</em></strong>.  Nearly all Python installations, with the exception of Ubuntu Linux, come pre-loaded with tkinter.   It is the "simplest" of the GUI frameworks to get up an running (among Qt, WxPython, Kivy, etc).</p>
<p>From the start of the PSG project, tkinter was not meant to be the only underlying GUI framework for PySimpleGUI.  It is merely a starting point.  All journeys begin with one step forward and choosing tkinter was the first of many steps for PySimpleGUI.</p>
<h2 id="author">Author</h2>
<p>MikeB</p>
<h2 id="demo-code-contributors">Demo Code Contributors</h2>
<p><a href="https://github.com/JorjMcKie">JorjMcKie</a> - PDF and image viewers (plus a number of code suggestions)    <br />
<a href="https://github.com/Otherion">Otherion</a> - Table Demos Panda &amp; CSV.  Loads of suggestions to the core APIs      </p>
<h2 id="license">License</h2>
<p>GNU Lesser General Public License (LGPL 3) +      </p>
<h2 id="acknowledgments">Acknowledgments</h2>
<h4 id="sorry-will-add-these-back-lost-due-to-file-length-limitation">SORRY!! Will add these back.  Lost due to file length limitation</h4>
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTE5MDU1OTQsMjA1MzEyNTE0OSwtMTU3OD
c0NjU4OCwyNjA1ODQ4MTQsMTEwMjA4ODMzMywxNjc5ODUwOTky
LC0xNDYxNDI4MSwtNjA2MzcxMTgsLTUwOTM1OTEyMywtMjQ4OT
c2MjksMTMwNzY5MjU5LC0yOTY3ODM1NSwtNzc0MDc0MjMwLDI2
NjM2NDQxNyw0NDk0MzMyNDMsLTExNDg0OTA2MjNdfQ==
--></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = ".",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="js/base.js" defer></script>
        <script src="search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2019-03-17 03:37:16
-->
